<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Bottom-up Clustering Approach to Unsupervised Person Re-identification 论文笔记</title>
    <url>/2020/10/12/A-Bottom-up-Clustering-Approach-to-Unsupervised-Person-Re-identification-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Yutian Lin， Liang Zheng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>AAAI 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>之前基于聚类的方法来做无监督ReID都需要一个源域来初始化，这篇论文用一张图代表一类来初始化，并且用层次聚类的方法逐步减少类别<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li> We propose a bottom-up clustering framework to solve the unsupervised re-ID problem. By exploiting the intrinsic diversity among identities and similarity within each identity, our framework can learn robust and discriminative features</li>
</ul>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012055951.png"><br>刚开始用一张图代表一类来初始化，然后用层次聚类的方法逐步减少类别。</p>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012060105.png"><br>最常规的聚类打标签方法</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012060215.png"><br>第7，8行如何减小类别paper中用了minimum distance criterion，公式如下：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012060741.png"><br>其中d为欧氏距离，但是这会导致部分类别中的图片极具的膨胀，所以再加了一个正则项来约束：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012060921.png"><br>模代表这一类的图片数目，所以最终的距离表达式为：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012061026.png"></p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012061119.png"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>AP聚类</title>
    <url>/2020/10/19/AP%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="sklearn包中的AP算法"><a href="#sklearn包中的AP算法" class="headerlink" title="sklearn包中的AP算法"></a>sklearn包中的AP算法</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">cluster</span>.<span class="title">AffinityPropagation</span>(<span class="params">*, damping=<span class="number">0.5</span>, max_iter=<span class="number">200</span>, convergence_iter=<span class="number">15</span>, copy=True, preference=None, affinity=<span class="string">&#x27;euclidean&#x27;</span>, verbose=False, random_state=<span class="string">&#x27;warn&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li>preference: 参考度或称为偏好参数：是相似度矩阵中横轴纵轴索引相同的点，如s(i,i)，若按欧氏距离计算其值应为0，但在AP聚类中其表示数据点i作为聚类中心的程度，因此不能为0。迭代开始前假设所有点成为聚类中心的能力相同，因此参考度一般设为相似度矩阵中所有值得最小值或者中位数，但是参考度越大则说明个数据点成为聚类中心的能力越强，则最终聚类中心的个数则越多，如果不指定，则都设为相似度矩阵中的中位数；</li>
<li>damping=0.5: 阻尼因子,用于减少吸引信息和归属信息以防止更新减少吸引度和归属度信息时数据振荡，设置为 0.5 到 1 之间。</li>
<li>max_iter=200： 最大迭代次数；</li>
<li>convergence_iter=15： 聚类个数连续 convergence_iter 次迭代都不再改变，就停止迭代；</li>
<li>copy=True： 在 scikit-learn 很多接口中都会有这个参数的，就是是否对输入数据进行 copy 操作，以便不修改用户的输入数据；</li>
<li>affinity=’euclidean’： string，“precomputed” 或者 “euclidean”，“euclidean” 采用负的欧几里得距离（class中的参数）</li>
<li>verbose=False： int 类型，是否输出详细信息<a id="more"></a>
<h3 id="函数返回结果"><a href="#函数返回结果" class="headerlink" title="函数返回结果"></a>函数返回结果</h3></li>
<li>cluster_centers_indices : array, shape (n_clusters,) 聚类中心在所有数据中的索引，聚类中心是已有数据点。</li>
<li>labels : array, shape (n_samples,) 聚类标签，每个记录对应的种类，默认是从0开始的数字</li>
<li>n_iter : int 运行的迭代次数，只有 return_n_iter参数设置维True时才返回。</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>不需要指定最终聚类族的个数</li>
<li>已有的数据点作为最终的聚类中心，而不是新生成一个族中心</li>
<li>模型对数据的初始值不敏感</li>
<li>对初始相似度矩阵数据的对称性没有要求</li>
<li>相比于k-centers聚类方法，其结果的平方差误差较小</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="affinity-’euclidean’"><a href="#affinity-’euclidean’" class="headerlink" title="affinity=’euclidean’"></a>affinity=’euclidean’</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AffinityPropagation</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成的测试数据的中心点</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">-1</span>]]</span><br><span class="line"><span class="comment">##生成数据</span></span><br><span class="line">Xn, labels_true = make_blobs(n_samples=<span class="number">150</span>, centers=centers, cluster_std=<span class="number">0.5</span>,</span><br><span class="line">                            random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simi = []</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> Xn:</span><br><span class="line">    <span class="comment">##每个数字与所有数字的相似度列表，即矩阵中的一行</span></span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> Xn:</span><br><span class="line">         <span class="comment">##采用负的欧式距离计算相似度</span></span><br><span class="line">        s =-np.sqrt((m[<span class="number">0</span>]-n[<span class="number">0</span>])**<span class="number">2</span> + (m[<span class="number">1</span>]-n[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">        temp.append(s)</span><br><span class="line">    simi.append(temp)</span><br><span class="line"></span><br><span class="line">p=<span class="number">-50</span>   <span class="comment">##3个中心</span></span><br><span class="line"><span class="comment">#p = np.min(simi)  ##9个中心，</span></span><br><span class="line"><span class="comment">#p = np.median(simi)  ##13个中心    </span></span><br><span class="line"></span><br><span class="line">ap = AffinityPropagation(damping=<span class="number">0.5</span>,max_iter=<span class="number">500</span>,convergence_iter=<span class="number">30</span>,</span><br><span class="line">                         preference=p).fit(Xn)</span><br><span class="line">cluster_centers_indices = ap.cluster_centers_indices_</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> cluster_centers_indices:</span><br><span class="line">    print(Xn[idx])</span><br></pre></td></tr></table></figure>

<h4 id="affinity-’precomputed’"><a href="#affinity-’precomputed’" class="headerlink" title="affinity=’precomputed’"></a>affinity=’precomputed’</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AffinityPropagation</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 计算欧氏距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caldist</span>(<span class="params">qf, gf</span>):</span></span><br><span class="line">    m, n = qf.shape[<span class="number">0</span>], gf.shape[<span class="number">0</span>]</span><br><span class="line">    distmat = torch.pow(qf, <span class="number">2</span>).sum(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>).expand(m, n) + \</span><br><span class="line">              torch.pow(gf, <span class="number">2</span>).sum(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>).expand(n, m).t()</span><br><span class="line">    distmat.addmm_(<span class="number">1</span>, <span class="number">-2</span>, qf, gf.t())</span><br><span class="line">    <span class="keyword">return</span> -distmat<span class="comment"># 取负值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试数据</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">-1</span>]]</span><br><span class="line"><span class="comment"># 生成实际中心为centers的测试样本300个，X是包含300个(x,y)点的二维数组，labels_true为其对应的真是类别标签</span></span><br><span class="line">X, labels_true = make_blobs(n_samples=<span class="number">300</span>, centers=centers, cluster_std=<span class="number">0.5</span>,</span><br><span class="line">                            random_state=<span class="number">0</span>)</span><br><span class="line">distMat = caldist(torch.from_numpy(X), torch.from_numpy(X)).numpy()</span><br><span class="line"><span class="comment"># 计算AP</span></span><br><span class="line">ap = AffinityPropagation(preference=<span class="number">-50</span>, affinity=<span class="string">&#x27;precomputed&#x27;</span>).fit(distMat)</span><br><span class="line">cluster_centers_indices = ap.cluster_centers_indices_    <span class="comment"># 预测出的中心点的索引，如[123,23,34]</span></span><br><span class="line">labels = ap.labels_    <span class="comment"># 预测出的每个数据的类别标签,labels是一个NumPy数组</span></span><br><span class="line"></span><br><span class="line">n_clusters_ = len(cluster_centers_indices)    <span class="comment"># 预测聚类中心的个数</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;预测的聚类中心个数：%d&#x27;</span> % n_clusters_)</span><br><span class="line">print(<span class="string">&#x27;同质性：%0.3f&#x27;</span> % metrics.homogeneity_score(labels_true, labels))</span><br><span class="line">print(<span class="string">&#x27;完整性：%0.3f&#x27;</span> % metrics.completeness_score(labels_true, labels))</span><br><span class="line">print(<span class="string">&#x27;V-值： % 0.3f&#x27;</span> % metrics.v_measure_score(labels_true, labels))</span><br><span class="line">print(<span class="string">&#x27;调整后的兰德指数：%0.3f&#x27;</span> % metrics.adjusted_rand_score(labels_true, labels))</span><br><span class="line">print(<span class="string">&#x27;调整后的互信息： %0.3f&#x27;</span> % metrics.adjusted_mutual_info_score(labels_true, labels))</span><br><span class="line">print(<span class="string">&#x27;轮廓系数：%0.3f&#x27;</span> % metrics.silhouette_score(X, labels, metric=<span class="string">&#x27;sqeuclidean&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图表展示</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"></span><br><span class="line">plt.close(<span class="string">&#x27;all&#x27;</span>)    <span class="comment"># 关闭所有的图形</span></span><br><span class="line">plt.figure(<span class="number">1</span>)    <span class="comment"># 产生一个新的图形</span></span><br><span class="line">plt.clf()    <span class="comment"># 清空当前的图形</span></span><br><span class="line"></span><br><span class="line">colors = cycle(<span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>)</span><br><span class="line"><span class="comment"># 循环为每个类标记不同的颜色</span></span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> zip(range(n_clusters_), colors):</span><br><span class="line">    <span class="comment"># labels == k 使用k与labels数组中的每个值进行比较</span></span><br><span class="line">    <span class="comment"># 如labels = [1,0],k=0,则‘labels==k’的结果为[False, True]</span></span><br><span class="line">    class_members = labels == k</span><br><span class="line">    cluster_center = X[cluster_centers_indices[k]]    <span class="comment"># 聚类中心的坐标</span></span><br><span class="line">    plt.plot(X[class_members, <span class="number">0</span>], X[class_members, <span class="number">1</span>], col + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    plt.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], markerfacecolor=col,</span><br><span class="line">             markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> X[class_members]:</span><br><span class="line">        plt.plot([cluster_center[<span class="number">0</span>], x[<span class="number">0</span>]], [cluster_center[<span class="number">1</span>], x[<span class="number">1</span>]], col)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;预测聚类中心个数：%d&#x27;</span> % n_clusters_)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>AD-Cluster: Augmented Discriminative Clustering for Domain Adaptive Person Re-identification 论文笔记</title>
    <url>/2020/10/12/AD-Cluster-Augmented-Discriminative-Clustering-for-Domain-Adaptive-Person-Re-identification-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Yunpeng Zhai</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>CVPR 2020</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>用一般的聚类方式会丢弃掉很多离群点，这些离群点是困难样本包含很多信息，那么既然聚类只能保留较为简单的样本，那么不妨那这些样本用GAN来生成困难样本，辅助网络的训练。</p>
<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p>it proposes a novel discriminative clustering method that addresses domain adaptive person re-ID by density-based clustering, adaptive sample augmentation, and discriminative feature learning. </p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012084312.png"><br>整个pipeline分三个部分，第一个部分是聚类Density-based Clustering，很常规；第二部分是 Adaptive Sample Augmentation，实际上就是StarGAN，将一个摄像头的图片迁移到其它摄像头下，生成的时候希望图片的类内距离尽可能大，第三部分拿了第一部分的CNN作为backbone，后面接个分类器用Triplet loss约束训练，实际上是在最小化类内距离。第二部分和第三部分要交替进行，最终我们的测试模型是CNN backbone。</p>
<h3 id="Density-based-Clustering"><a href="#Density-based-Clustering" class="headerlink" title=" Density-based Clustering"></a> Density-based Clustering</h3><p>用了一种基于密度的聚类方法，由于不是paper的创新点，所以不讲了</p>
<h3 id="Adaptive-Sample-Augmentation"><a href="#Adaptive-Sample-Augmentation" class="headerlink" title=" Adaptive Sample Augmentation"></a> Adaptive Sample Augmentation</h3><p>用StarGAN迁移图片，大家可以看看StarGAN的原文，也可以看看HHL方法。<br>用StarGAM迁移完图片之后，我们就有了:<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012085051.png"><br>注意这个image generator（stargan）训练的时候要提高图片多样性，也就是说要hard一些；首先定义多样性：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012085319.png"><br>$x_{t,i}$为数据集上的第i张真图，g为StarGAN，f为CNN backbone，$a(i,j)$表示$x_{t,i}$和$x_{t,j}$如果是同一个ID那么为1，不同ID为0（这个ID是聚类得到的）。$x_{t,i}$通过g（StarGAN）生成很多假图，用f（CNN backbone）提特征，然后算到类别中心的距离，把这个距离当成是多样性，距离越大表示多样性越大。值得注意的是公式好像<strong>写错了</strong>，最后的那个$f(x_{t,i})$应该是$f(x_{t,j})$，不然的话$a(i,j)$就可以直接消掉了……迷惑……<br>因为我们要最大化多样性，所以定义Loss为：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012090002.png"><br>这样的话，最小化loss就相当于是最大化多样性。</p>
<h3 id="Discriminative-Learning"><a href="#Discriminative-Learning" class="headerlink" title="Discriminative Learning"></a>Discriminative Learning</h3><p>这部分很简单，复用最左边的CNN backbone，然后将输出的特征用三元组损失函数训练就行。</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012090317.png"></p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012090350.png"><br>性能很好~</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL之Queue</title>
    <url>/2020/10/26/C-STL%E4%B9%8BQueue/</url>
    <content><![CDATA[<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>q.empty()：判断队列是否为空</li>
<li>q.front()：返回队列头部元素</li>
<li>q.back()：返回队列尾部元素</li>
<li>q.pop()：弹出队列头部元素，注意返回为void，而不是头部元素</li>
<li>q.push()：讲x添加至队尾</li>
<li>q.size()：返回队列的存储元素个数</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL之Stack</title>
    <url>/2020/10/26/C-STL%E4%B9%8BStack/</url>
    <content><![CDATA[<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>s.top()：取出栈顶</li>
<li>s.empty()：判断栈是否为空</li>
<li>s.push(x)：讲x添加至栈</li>
<li>s.pop()：弹出栈顶，<strong>注意返回为void，而不是栈顶元素</strong></li>
<li>s.size()：栈的存储元素个数</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::copy用法</title>
    <url>/2020/10/17/C-std-copy%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>把一个序列（sequence）拷贝到一个容器（container）中去。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::copy(start, end, <span class="built_in">std</span>::back_inserter(container));</span><br></pre></td></tr></table></figure>
<p>std::back_inserter可以替换成std::front_inserter和std::inserter</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> vi = inserter(v, v.begin() + <span class="number">1</span>);</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	copy(v1.begin(), v1.end(), vi);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++前向引用声明</title>
    <url>/2020/10/12/C-%E5%89%8D%E5%90%91%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>类应该先声明，后使用</li>
<li>如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。</li>
<li>前向引用声明只为程序引入一个<strong>标识符</strong>，但具体声明在其他地方。</li>
<li>前向引用声明不能声明该类的对象, 也不能在内联成员函数中使用该类的对象, <strong>只能声明该类的指针, 引用, 函数形参和返回类型。</strong><a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="正确使用"><a href="#正确使用" class="headerlink" title="正确使用"></a>正确使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span>  </span><br><span class="line"><span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Class A中需要用到B，作为函数f的形参，而此时B还没有被定义，所以需要前向引用声明</li>
</ul>
<h3 id="错误使用"><a href="#错误使用" class="headerlink" title="错误使用"></a>错误使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barney</span> &#123;</span></span><br><span class="line">   Fred x; <span class="comment">//错误：类Fred的声明尚不完善</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span> &#123;</span></span><br><span class="line">   Barney y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能用Fred来实例化对象，因为实例化对象需要知道Fred类的内部细节，而单单一个前向引用声明是无法得知具体细节的，需要到定义时才能知道</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.xuetangx.com/learn/THU08091000247/THU08091000247/5430764/video/7472294">https://www.xuetangx.com/learn/THU08091000247/THU08091000247/5430764/video/7472294</a></li>
<li><a href="https://blog.csdn.net/zy704599894/article/details/79699292">https://blog.csdn.net/zy704599894/article/details/79699292</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++拷贝构造函数</title>
    <url>/2020/10/12/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>拷贝构造函数的定义</li>
<li>拷贝构造函数的使用<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">classname</span> (const <span class="built_in">classname</span> &amp;obj) &#123; </span><br><span class="line">    <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
复制构造函数的参数可以是 const 引用，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;</span><br><span class="line">        real = r; imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Complex(<span class="keyword">const</span> Complex &amp; c)&#123;</span><br><span class="line">        real = c.real; imag = c.imag;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Copy Constructor called&quot;</span>&lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">cl</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span> <span class="params">(cl)</span></span>;  <span class="comment">//调用复制构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c2.real&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c2.imag;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ul>
<h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1;</span><br></pre></td></tr></table></figure>
<p>这两条语句是等价的。</p>
<p>注意，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex c1, c2; c1 = c2 ;</span><br><span class="line">c1=c2;</span><br></pre></td></tr></table></figure>
<p>所以说复制构造函数突出<strong>构造</strong>，只有在实例化新对象的时候才会调用。</p>
<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    A(A &amp; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Copy constructor called&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(A a)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Func(a);<span class="comment">//形实结合时调用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果为：<br>Copy constructor called<br>这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。</p>
<h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><p>如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n) &#123; v = n; &#125;;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Func().v &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//返回时调用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：<br>Copy constructor called<br>4</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://c.biancheng.net/view/151.html">http://c.biancheng.net/view/151.html</a></li>
<li><a href="https://www.xuetangx.com/learn/THU08091000247/THU08091000247/5430764/video/7472287">https://www.xuetangx.com/learn/THU08091000247/THU08091000247/5430764/video/7472287</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++插入迭代器</title>
    <url>/2020/10/17/C-%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>三类插入迭代器与容器的绑定</li>
<li>利用插入迭代器插入元素</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>指定位置插入元素</p>
<a id="more"></a>
<h2 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>其内部调用push_back()</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>每次都在容器的尾端插入元素</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>只有提供了push_back()成员函数的容器中，back inserter才能派上用场。<br>适用：vector deque list</p>
<h2 id="front-inserter"><a href="#front-inserter" class="headerlink" title="front_inserter"></a>front_inserter</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其内部调用push_front()</p>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>每次都在容器的前端插入元素</p>
<h3 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h3><p>只有提供了push_front()成员函数的容器中，front inserter才能派上用场<br>适用：deque list （由于vector不提供头插操作所以不能用） </p>
<h2 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>其内部调用insert()</p>
<h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>在容器的指定位置插入元素；每次插入之后下一次插入的位置会向后移动一位</p>
<h3 id="使用限制-2"><a href="#使用限制-2" class="headerlink" title="使用限制"></a>使用限制</h3><p>只有提供了inset()成员函数的容器中，inserter才能派上用场. 所有STL容器都提供了inset()函数.<br>适用：所有STL容器 </p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">       <span class="keyword">auto</span> vi = inserter(v, v.begin() + <span class="number">1</span>);</span><br><span class="line">       *vi = <span class="number">2</span>;</span><br><span class="line">       *vi = <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluating Multiple Object Tracking Performance:The CLEAR MOT Metrics 论文笔记</title>
    <url>/2020/10/13/Evaluating-Multiple-Object-Tracking-Performance-The-CLEAR-MOT-Metrics-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Keni Bernardin and Rainer Stiefelhagen</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>EURASIP Journal on Image and Video Processing</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>给出一种tracking结果到GT的映射</li>
<li>提出两种评价MOT tracker的指标<strong>MOTP</strong>和<strong>MOTA</strong><a id="more"></a>
<h2 id="metric"><a href="#metric" class="headerlink" title="metric"></a>metric</h2><h3 id="价指标应该满足的要求"><a href="#价指标应该满足的要求" class="headerlink" title="价指标应该满足的要求"></a>价指标应该满足的要求</h3></li>
</ul>
<ol>
<li>所有出现的目标都要能够及时找到</li>
<li>找到目标位置要尽可能可真实目标位置一致</li>
<li>保持追踪一致性，避免跟踪目标的跳变</li>
</ol>
<h3 id="评价过程"><a href="#评价过程" class="headerlink" title="评价过程"></a>评价过程</h3><ol>
<li>建立目标和假设间的最优一一对应关系，称之为correspondence</li>
<li>对所有的correspondence，</li>
<li>计算位置偏移误差(the error in the object’s position estimation)累积结构误差(object configuration error)<br>a. 计算漏检数，objects for which no hypothesis was output<br>b. 计算虚警数，hypothesis for which no real objects exists<br>c. 跟踪目标发生跳变的次数，the number of occurrences where the tracking hypothesis for an object changed compared to previous frames</li>
</ol>
<h4 id="建立目标和假设间的最优一一对应关系"><a href="#建立目标和假设间的最优一一对应关系" class="headerlink" title="建立目标和假设间的最优一一对应关系"></a>建立目标和假设间的最优一一对应关系</h4><p>$M$表示从GT到tracking结果的映射，$o_i$表示GT中的第$i$个行人的轨迹，$h_j$表示tracking结果中第$j$条tracklet，在计算目标和假设间的最优对应关系时，需要统计跳变数、漏检数、虚警数。</p>
<ol>
<li>对于第$t$帧，考虑<strong>直到</strong>$t-1$时刻的映射$M_{t-1}$，判断其中的每一个对应$(o_i,h_j)$是否有效</li>
<li>对于那些上一步没有找到对应假设的目标，在新的假设集中寻找最佳匹配，具体匹配算法是用匈牙利匹配算法，此时新出现的$(o_i,h_k)$不在$M_{t-1}$中，那么更新映射表，在$M_{t}$中将新的$(o_i,h_k)$取代$o_i$以前的对应$(o_i,h_j)$，同时使用${mmr}_t$记录$t$时刻出现的跳变次数。</li>
<li>经过之前两步，可以找到所有的correspondence，所有的correspondence个数记为$c_t$,计算每一个correspondence计算目标和假设建的距离$d_t^i$，这两个数据用来算最终的metric</li>
<li>剩下的未找到correspondence的目标和假设个数分别记为$m_{t}$和${fp}<em>{t}$，分别是第$t$帧的false negative和false positive，使用$g</em>{t}$表示$t$时刻GT中的目标数</li>
<li>对于初始的第1帧$M_{1}$而言，把$M_{0}$是空的，第1帧出现的所有$o$与$h$都用匈牙利匹配算法，并且认为所有匹配都是正确的，没有发生跳变。</li>
</ol>
<p><strong>值得注意的一点是这里说直至$t$时刻的目标-假设映射表而不是$t$时刻的映射表是因为有时correspondence出现丢失时，之前的对应关系应该得到保留</strong>。如下图所示：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201013055832.png"><br>$t+1$时刻的映射$M_{t+1}$，目标$o_i$没有对应的假设$h_j$与之对应，也就是false negative的情况，但$t$时刻的目标$o_i$与对应的$h_j$，所以在$t+2$时刻虽然$d_{(1,1) }&gt;d_{(1,2) }$，但任选择$(o_1,h_1)$</p>
<h3 id="两个指标"><a href="#两个指标" class="headerlink" title="两个指标"></a>两个指标</h3><h4 id="MOTA"><a href="#MOTA" class="headerlink" title="MOTA"></a>MOTA</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201013060906.png"></p>
<ul>
<li>$m_{t}$为MOT tracking的detection过程总体的漏检率</li>
<li>${fp}_{t}$为MOT tracking的detection过程总体的虚警率</li>
<li>${mmr}_t$为MOT tracking中所有目标ID发生跳变的机率</li>
</ul>
<p>这个指标比较关注detection的结果。</p>
<h4 id="MOPT"><a href="#MOPT" class="headerlink" title="MOPT"></a>MOPT</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201013061315.png"></p>
<p>这个指标用来衡量假设与对应目标的平均偏差，也就是bbox的偏差。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.cnblogs.com/YiXiaoZhou/p/5937980.html">https://www.cnblogs.com/YiXiaoZhou/p/5937980.html</a></li>
<li><a href="https://blog.csdn.net/qq_36342854/article/details/102984622">https://blog.csdn.net/qq_36342854/article/details/102984622</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>MOT</tag>
      </tags>
  </entry>
  <entry>
    <title>Generalizing A Person Retrieval Model Hetero- and Homogeneously 论文笔记</title>
    <url>/2020/10/07/Generalizing-A-Person-Retrieval-Model-Hetero-and-Homogeneously-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Zhun Zhong, Liang Zheng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>ECCV 2018</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>以往的做法(SPGAN,PTGAN)都是只考虑源域与目标域之间的bias，没有考虑目标域不同摄像机的bias</li>
<li>目标域不同相机之间也可以看出是一个跨域任务<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li>提出了一种新的跨域学习的pipeline</li>
</ul>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://s1.ax1x.com/2020/10/07/0dqjt1.png" alt="pipeline"></p>
<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><ul>
<li>在源域上用CE loss和Triplet loss约束训练</li>
<li>在目标域上测试</li>
</ul>
<h3 id="HHL"><a href="#HHL" class="headerlink" title="HHL"></a>HHL</h3><p>用StarGAN在目标域上不同相机之间迁移图片，在此基础上提出两个不变性</p>
<h4 id="相机不变性"><a href="#相机不变性" class="headerlink" title="相机不变性"></a>相机不变性</h4><p>迁移前后的图片应该保证ID不变(理想情况，事实上StarGAN根本没法做到这一点)，这样迁移前后的图片就构成了正对，负样本从目标域上的原图中随机选取，严格意义上这并不成立，但是由于原图上正样本很少，所以可以看成是一种近似，作者在最后的实验中也验证了，影响不大。对应的loss为：<br><img src="https://s1.ax1x.com/2020/10/07/0dOzLD.png" alt="pipeline"><br>$t$表示目标域上的真图，$n_t$为目标域真图的所有图片数目，$t^\star$为目标域上的假图，$n_t^\star$为目标域假图的所有图片数目。</p>
<h4 id="域连通性"><a href="#域连通性" class="headerlink" title="域连通性"></a>域连通性</h4><p>源域目标域图片不重叠，所以构成天然的负对，由于源域带label所以可以找出正对，对饮的loss为：<br><img src="https://s1.ax1x.com/2020/10/07/0djc3q.png" alt="pipeline"><br>$s$表示源域上的真图，$n_s$为源域真图的所有图片数目，$t$表示目标域上的真图，$n_t$为目标域真图的所有图片数目。</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><h3 id="StarGAN迁移结果"><a href="#StarGAN迁移结果" class="headerlink" title="StarGAN迁移结果"></a>StarGAN迁移结果</h3><p><img src="https://s1.ax1x.com/2020/10/07/0djH81.png" alt="pipeline"></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="https://s1.ax1x.com/2020/10/07/0djqv6.png" alt="pipeline"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用指南</title>
    <url>/2020/10/26/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="Git使用指南"><a href="#Git使用指南" class="headerlink" title="Git使用指南"></a>Git使用指南</h2><ul>
<li>初始化Git：<code>git init</code></li>
<li>查看状态：<code>git status</code></li>
<li>提交代码：<code>git add . git commit -m &#39;readme&#39;</code></li>
<li>创建分支：<code>git branch newbranch</code></li>
<li>切换分支：<code>git checkout branch</code></li>
<li>查看所有分支：<code>git branch</code></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hierarchical Clustering with Hard-batch Triplet Loss for Person Re-identification 论文笔记</title>
    <url>/2020/10/12/Hierarchical-Clustering-with-Hard-batch-Triplet-Loss-for-Person-Re-identification-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Kaiwei Zeng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>CVPR 2020</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>一般的聚类会舍弃掉离群点，导致无法挖掘困难样本，该方法使用一种层次聚类的方式，并采用Hard Triplet Loss重复挖掘苦难样本。同时基于聚类的方法一般需要用源域来初始化模型，用层次聚类的方法就可以避免.</p>
<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p> We propose a fully unsupervised re-IDmethod HCT. Based on pre-trained ResNet-50[8] on ImageNet, we directly use pseudo labels generated by hierarchical clustering as supervision to conduct model training on the target dataset without any manually annotated labels.</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012082510.png"><br>层次聚类很常见</p>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012082638.png"><br>常规的pipeline，要注意的是，这边在组织mini-batch的时候用了困难样本挖掘的采样方式，也就是选P个人，每个人随机选K张图</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012082828.png"><br>第七行类别合并准则为：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012082925.png"></p>
<h3 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h3><p>loss用了困难样本挖掘三元组损失<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012083045.png"></p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012083116.png"><br>性能很好，但是对参数很敏感</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Image Domain Adaptation with Preserved Self-Similarity and Domain-Dissimilarity for Person Re-identification 论文笔记</title>
    <url>/2020/10/07/Image-Image-Domain-Adaptation-with-Preserved-Self-Similarity-and-Domain-Dissimilarity-for-Person-Re-identification-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Weijian Deng, Liang Zheng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>CVPR 2018</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>直接迁移性能低，考虑用GAN将源域上的图片迁移到目标域上，迁移过程增加约束，保持ID不变。<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li>这是ReID任务中第一篇用GAN来解决无监督迁移学习的Paper。</li>
<li>提出了一个跨域迁移的pipeline，先用GAN生成ID相同，风格不同的图片。然后用生成的图片来训练网络。</li>
</ul>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://s1.ax1x.com/2020/10/07/0dExv4.png" alt="pipeline"></p>
<ul>
<li>similarity preserving image-to-image translation：先用GAN生成ID相同，风格不同的图片</li>
<li>feature learning：然后用生成的图片来训练网络</li>
<li>最后测试用的是feature learning步骤中的re-ID model而不是similarity preserving image-to-image translation步骤中的SiaNet</li>
</ul>
<h3 id="SiaNet"><a href="#SiaNet" class="headerlink" title="SiaNet"></a>SiaNet</h3><h4 id="Model模型"><a href="#Model模型" class="headerlink" title="Model模型"></a>Model模型</h4><p><img src="https://s1.ax1x.com/2020/10/07/0dVXdI.png" alt="pipeline"></p>
<ul>
<li>本质上是一个CycleGAN，再加了一个Discriminator(SiaNet)</li>
<li>训练的时候分三个模块训练，分别是$G,F$，$D_S,D_T$和$SiaNet$，其中一个模块训练时，固定其它两个模块</li>
</ul>
<h4 id="Loss损失函数"><a href="#Loss损失函数" class="headerlink" title="Loss损失函数"></a>Loss损失函数</h4><p><strong>GAN loss</strong><br><img src="https://s1.ax1x.com/2020/10/07/0dZqpT.png" alt="S2T GAN Loss"><br><img src="https://s1.ax1x.com/2020/10/07/0dZz7R.png" alt="T2S GAN Loss"></p>
<p><strong>cycle-consistent loss</strong><br><img src="https://s1.ax1x.com/2020/10/07/0deuNt.png" alt="cycle-consistent loss"></p>
<p><strong>identity loss</strong><br><img src="https://s1.ax1x.com/2020/10/07/0degER.png" alt="identity loss"></p>
<p>加上这个loss的目的是为了让颜色不要突变，如果只有(1)(2)(3)三个公式，可以把一个白皮肤的人变成黑皮肤，再变回白皮肤，这种变换可以使前三个loss很低，但是不符合保持ID不变的要求。</p>
<p><strong>SiaNet Contrastive Loss</strong><br><img src="https://s1.ax1x.com/2020/10/07/0de4gO.png" alt="SiaNet Contrastive Loss"></p>
<p>加上这个loss是为了保持ID不变，采样规则如下：</p>
<ul>
<li>S域上的一张true image，通过G生成fake image，这两张图片构成正样本对；对T域上的图片同样处理。</li>
<li>S域上的一张true image，T域上的一张true image，这两种图片构成负样本对。</li>
</ul>
<h4 id="从三个模块的角度看Loss"><a href="#从三个模块的角度看Loss" class="headerlink" title="从三个模块的角度看Loss"></a>从三个模块的角度看Loss</h4><h5 id="Train-the-Generator"><a href="#Train-the-Generator" class="headerlink" title="Train the Generator"></a>Train the Generator</h5><p>由四个Loss约束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Positive Pair</span></span><br><span class="line"><span class="comment">#a是S域上的真图，a2b是T域上的假图，metric的意思是经过SiaNet网络，128-dim</span></span><br><span class="line">loss_pos0 = sia_criterion(a_metric, a2b_metric, <span class="number">0</span>)</span><br><span class="line">loss_pos1 = sia_criterion(b_metric, b2a_metric, <span class="number">0</span>)</span><br><span class="line"><span class="comment">#Negative_Pair</span></span><br><span class="line">loss_neg0 = sia_criterion(a2b_metric, b_metric, <span class="number">1</span>)</span><br><span class="line">loss_neg1 = sia_criterion(b2a_metric, a_metric, <span class="number">1</span>)</span><br><span class="line">loss_neg= sia_criterion(a_metric, b_metric, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#contrastive loss for G</span></span><br><span class="line">m_loss_G = (loss_pos0 + loss_pos1 + <span class="number">0.5</span>*(loss_neg0 + loss_neg1)) / <span class="number">4.0</span></span><br><span class="line">m_loss_M = (loss_pos0 + loss_pos1 + <span class="number">2</span>* loss_neg) / <span class="number">3.0</span></span><br><span class="line"><span class="comment"># identity loss</span></span><br><span class="line">b2b = Gb(b_real)</span><br><span class="line">a2a = Ga(a_real)</span><br><span class="line">idt_loss_b = L1(b2b, b_real)</span><br><span class="line">idt_loss_a = L1(a2a, a_real)</span><br><span class="line">idt_loss = idt_loss_a + idt_loss_b</span><br><span class="line"></span><br><span class="line"><span class="comment"># gen losses</span></span><br><span class="line"><span class="comment"># 假图拉到1</span></span><br><span class="line">a_f_dis = Da(a_fake)</span><br><span class="line">b_f_dis = Db(b_fake)</span><br><span class="line">r_label = torch.ones(a_f_dis.size()).to(device)</span><br><span class="line">a_gen_loss = MSE(a_f_dis, r_label)</span><br><span class="line">b_gen_loss = MSE(b_f_dis, r_label)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rec losses</span></span><br><span class="line">a_rec_loss = L1(a_rec, a_real)</span><br><span class="line">b_rec_loss = L1(b_rec, b_real)</span><br><span class="line">rec_loss = a_rec_loss + b_rec_loss</span><br></pre></td></tr></table></figure>
<h5 id="Train-the-Siamese-Network"><a href="#Train-the-Siamese-Network" class="headerlink" title="Train the Siamese Network"></a>Train the Siamese Network</h5><p>只有contrastive loss约束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Positive Pair</span></span><br><span class="line">loss_pos0 = sia_criterion(a_metric, a2b_metric, <span class="number">0</span>)</span><br><span class="line">loss_pos1 = sia_criterion(b_metric, b2a_metric, <span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(loss_pos1, type(loss_pos1))</span></span><br><span class="line"><span class="comment">#Negative_Pair</span></span><br><span class="line">loss_neg= sia_criterion(a_metric, b_metric, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#contrastive loss for Sia</span></span><br><span class="line">m_loss_M = (loss_pos0 + loss_pos1 + <span class="number">2</span>*loss_neg) / <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<h5 id="Train-the-Discriminator"><a href="#Train-the-Discriminator" class="headerlink" title="Train the Discriminator "></a>Train the Discriminator </h5><p>只有GAN loss约束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Training D</span></span><br><span class="line">a_r_dis = Da(a_real)</span><br><span class="line">a_f_dis = Da(a_fake)</span><br><span class="line">b_r_dis = Db(b_real)</span><br><span class="line">b_f_dis = Db(b_fake)</span><br><span class="line">r_label = torch.ones(a_f_dis.size()).to(device)</span><br><span class="line">f_label = torch.zeros(a_f_dis.size()).to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d loss</span></span><br><span class="line"><span class="comment"># 真图拉到1，假图拉到0</span></span><br><span class="line">a_d_r_loss = MSE(a_r_dis, r_label)</span><br><span class="line">a_d_f_loss = MSE(a_f_dis, f_label)</span><br><span class="line">b_d_r_loss = MSE(b_r_dis, r_label)</span><br><span class="line">b_d_f_loss = MSE(b_f_dis, f_label)</span><br><span class="line"></span><br><span class="line">a_d_loss = (a_d_r_loss + a_d_f_loss)*<span class="number">0.5</span></span><br><span class="line">b_d_loss = (b_d_r_loss + b_d_f_loss)*<span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><h3 id="迁移结果"><a href="#迁移结果" class="headerlink" title="迁移结果"></a>迁移结果</h3><p><img src="https://s1.ax1x.com/2020/10/07/0dnZFI.png" alt="迁移结果"></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="https://s1.ax1x.com/2020/10/07/0dn3wj.png" alt="性能"></p>
<h2 id="补充：什么是LMP"><a href="#补充：什么是LMP" class="headerlink" title="补充：什么是LMP"></a>补充：什么是LMP</h2><p><img src="https://s1.ax1x.com/2020/10/07/0dnOc8.png" alt="性能"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Invariance Matters Exemplar Memory for Domain Adaptive Person Re-identificatio论文笔记</title>
    <url>/2020/08/27/Invariance-Matters-Exemplar-Memory-for-Domain-Adaptive-Person-Re-identificatio%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Zhun Zhong, Liang Zheng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>CVPR 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>在迁移学习的过程中，不仅要考虑source domain与target domain之间的domain bias，还要考虑target domain内部的bias。简单来说target domain中的每一个camera都是一个domain，在监督学习下，这些camera-level的domain bias很容易通过网络学出来，但在无监督学习下却不行。</li>
</ul>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul>
<li>提出exemplar-invariance, camera- invariance and neighborhood-invariance三种不变性约束。</li>
<li>提出memory module来充分利用整个training set上的样本。</li>
</ul>
<a id="more"></a>

<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://img-blog.csdnimg.cn/20191210161738447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="framework"></p>
<h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p>蓝色支路为baseline，输入为source domain上带标签的图片，用cross entropy loss做约束，损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20191210162135330.png" alt="在这里插入图片描述"><br>$n_{s}$为source domain上图片的数量，$x_{s,i}$为source domain上的第$i$张图片，$y_{s,i}$为其label。</p>
<h2 id="Exemplar-Memory"><a href="#Exemplar-Memory" class="headerlink" title="Exemplar Memory"></a>Exemplar Memory</h2><p>Exemplar Memory为key-value结构，key存储经过L2正则化之后的4096维特征，value存储label(实际上为index)，value在训练过程中保持不变。<br>key初始化为0，在BP时更新，方法如下：<br><img src="https://img-blog.csdnimg.cn/2019121016300286.png" alt="在这里插入图片描述"><br>$\alpha$在[0, 1]的范围内，控制更新速度，为一个超参数。下面用Exemplar Memory模块来完成三种不变性约束。</p>
<h3 id="Exemplar-invariance"><a href="#Exemplar-invariance" class="headerlink" title="Exemplar-invariance"></a>Exemplar-invariance</h3><p>每张图的appearence都是独一无二的，就算是相同ID的图片，也会受到pose，illumination，background等因素的影响，所以对于每张图，都应该靠近自己(Exemplar Memory的作用)而远离其它图片，作者视每张图都为不同的id，然后将每张图归于自己的id。实际上就是训练一个$N_t$($N_t$为target domain上图片数目)个类的分类器，概率如下：<br><img src="https://img-blog.csdnimg.cn/20191210164027839.png" alt="在这里插入图片描述"><br>$f(x_{t,i})$为backbone输出的4096维特征，与Exemplar Memory中的每个特征计算余弦距离，$\beta$为smooth项，$\beta$越大输出越均匀。</p>
<h3 id="Camera-invariance"><a href="#Camera-invariance" class="headerlink" title="Camera-invariance"></a>Camera-invariance</h3><p>用StarGAN来风格迁移，将每一张图片都迁移到其他$C-1$个相机下。迁移过程中保证ID不变，camstyle变成对应camid的style。损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20191210165159127.png" alt="在这里插入图片描述"><br>$\hat{x}<em>{t,i}$为由$x</em>{t,i}$风格迁移得到的图片，这张图片应该与$x_{t,i}$属于相同id。</p>
<h3 id="Neighborhood-invariance"><a href="#Neighborhood-invariance" class="headerlink" title="Neighborhood-invariance"></a>Neighborhood-invariance</h3><p>对于target domain上的每张图，都存在其他正例，只是在这个问题定义下我们不知道而已。对于每一张图片的输出$f(x_{t,i})$我们可以在key张找到k-nearest近邻，显然最近的是自己。$M(x_{t,i},k)$表示离$f(x_{t,i})$最近的k个近邻的value值。<br>作者认为$M(x_{t,i},k)$中的k张图最有可能与$f(x_{t,i})$拥有相同的id，所以希望在特征空间中拉近彼此之间的距离，但是这种伪标签又是不可信的，所以不能赋予太高的权重。权重如下：<br><img src="https://img-blog.csdnimg.cn/20191210170510387.png" alt="在这里插入图片描述"><br>对$f(x_{t,i})$自身赋予1，其余赋予$\frac{1}{k}$的权重。损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20191210170734221.png" alt="在这里插入图片描述"><br>这个损失函数中为了与exemplar-invariance区别将自身剔除了。</p>
<h3 id="Overall-loss-of-invariance-learning"><a href="#Overall-loss-of-invariance-learning" class="headerlink" title="Overall loss of invariance learning"></a>Overall loss of invariance learning</h3><p><img src="https://img-blog.csdnimg.cn/20191210170924743.png" alt="在这里插入图片描述"><br>将三种不变性loss合在一起写简单明了。</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><h3 id="beta-的影响"><a href="#beta-的影响" class="headerlink" title="$\beta$的影响"></a>$\beta$的影响</h3><p><img src="https://img-blog.csdnimg.cn/20191210171159729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Memory的影响"><a href="#Memory的影响" class="headerlink" title="Memory的影响"></a>Memory的影响</h3><p><img src="https://img-blog.csdnimg.cn/20191210171321178.png" alt="在这里插入图片描述"><br>memroy module的计算开销小，效果提升显著，非常值得借鉴。</p>
<h3 id="Ablation-experiment-on-invariance-learning"><a href="#Ablation-experiment-on-invariance-learning" class="headerlink" title="Ablation experiment on invariance learning"></a>Ablation experiment on invariance learning</h3><p><img src="https://img-blog.csdnimg.cn/20191210171538692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="SOTA性能"><a href="#SOTA性能" class="headerlink" title="SOTA性能"></a>SOTA性能</h3><p><img src="https://img-blog.csdnimg.cn/20191210171626835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Joint Discriminative and Generative Learning for Person Re-identification 论文笔记</title>
    <url>/2020/10/12/Joint-Discriminative-and-Generative-Learning-for-Person-Re-identification-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Zhedong Zheng，Liang Zheng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>CVPR 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>用GAN做数据增强</p>
<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p>this work provides the first framework that is able to end-to-end integrate discriminative and generative learning in a single unified network for person re-id.</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://s1.ax1x.com/2020/10/12/02D5es.png"><br>总体上看首先将appearence和structure分开编码，然后交换appearence code和structure code，重新组合生成新的图片，进行训练。</p>
<h3 id="self-identity-generation"><a href="#self-identity-generation" class="headerlink" title="self-identity generation"></a>self-identity generation</h3><p>$x_i$和$x_t$是同一个人的两张图，$x_i$通过$E_a$得到appearence code（不妨记为$a_i$），并通过$E_s$得到structure code（$s_i$），重新组合通过$G$生成原图，然后用pixel level的L1 loss约束训练，这一部分相当与是auto-encoder，同时我们可以用$x_t$通过$E_a$也得到appearance code（$a_t$）然后用$s_i$和$a_t$组合通过$D$生成$x_i^t$，因为$x_i$和$x_t$是一个人，那么我们希望网络提取的$a_i$和$a_t$也是相近的，所以将$x_i^t$和$x_i$用pixel level的L1 loss约束训练</p>
<h3 id="cross-identity-generation"><a href="#cross-identity-generation" class="headerlink" title="cross-identity generation"></a>cross-identity generation</h3><p>这部分和上面的<strong>self-identity generation</strong>过程相似，只不过$x_i$和$x_j$是不同的人，然后相互交换appearence code和structure code，重新组合生成新的图片，但是对于这个图片我们在数据集中没有对应的图片可以用来做L1 loss约束训练，但是我们可以将生成的图，比如$x_i^j$（表示appearence和$x_i$相同，structure和$x_j$相同），重新输入到$E_a$中提特征得然后与$a_i$与之前生成图片是提取到的$a_i$做L1 loss，对structure也是相同。</p>
<h3 id="L-id-c-和-L-fine"><a href="#L-id-c-和-L-fine" class="headerlink" title="$L_{id}^c$和$L_{fine}$"></a>$L_{id}^c$和$L_{fine}$</h3><p>这边把生成的假图$x_i^j$，即当成i有当成j，感觉迷惑，loss的形式如下：<br><img src="https://s1.ax1x.com/2020/10/12/026qE9.png"><br><img src="https://s1.ax1x.com/2020/10/12/02cpuD.png"><br>虽然用了不同的支路来训练，但是这真的能收敛吗……</p>
<h3 id="L-prim"><a href="#L-prim" class="headerlink" title="$L_{prim}$"></a>$L_{prim}$</h3><p>单独训练一个teacher model，用这个teacher model产生soft label（比如我们的数据集只有三个人ABC，用teacher model产生一个label0.2，0.5，0.3，这表示我们生成的假图想A的程度是0.2，像B的程度是0.5，像C的程度是0.3，我们希望Ea产生的分布也是这个）进行训练，loss的形式如下：<br><img src="https://s1.ax1x.com/2020/10/12/02cnKS.png"><br>这个loss很好理解……</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://s1.ax1x.com/2020/10/12/02gSGq.png"></p>
<h3 id="各种loss影响"><a href="#各种loss影响" class="headerlink" title="各种loss影响"></a>各种loss影响</h3><p><img src="https://s1.ax1x.com/2020/10/12/02gisU.png"><br>性能提升确实来自$L_{prim}$啊……<br>$L_{fine}$属实让人迷惑……</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Joint Disentangling and Adaptation for Cross-Domain Person Re-Identification 论文笔记</title>
    <url>/2020/10/12/Joint-Disentangling-and-Adaptation-for-Cross-Domain-Person-Re-Identification-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Yang Zou</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>ECCV 2020</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>将源域和目标域上图片的appearance信息（就是和id相关的信息）编码到相同的特征空间。区别与之前的SPGAN、PTGAN、HHL等方法，此类方法都是通过GAN生成一个新的数据集，然后在这个新的数据集上训练模型；而这篇论文生成图片的目的是为了训练更好的$E_{app}$（appearance编码器）</p>
<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul>
<li> we propose a joint learning framework for unsupervised cross-domain person re-id to disentangle id-related/unrelated factors so that adaptation can be more effectively performed on the id-related space.<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012033231.png"><br>从这张图中我们可以得到作者的意图：将图片的structure和appearance解耦合。最终我们需要的模型是编码appearance space的编码器，用这个模型来做测试.<br>那么什么是structure，什么是appearance呢？作者给出的解释是 The latent spaces incorporate a shared appearance space that captures id-related features (i.e., appearance and other semantics), a source structure space and a target structure space that contain id-unrelated features (i.e., pose, position,viewpoint, background and other variations). 实际上看网络结构，structure用了浅层网络提取，最终的feature map大小是128x64x32，而appearance由ResNet50提取，最终的feature map大小是2048x4x1。也就是说，structure代表的是底层信息，而appearance代表的是高层的语义信息。</li>
</ul>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012035308.png"><br>总体上来看是cyclegan的结果，采用这种结构应该是为了更好的利用自监督信息。<br>将源域、目标域上的图片$x_{s(i)}$和$x_{t(j)}$用共同的$E_{app}$提取高层语义信息，这些信息与id相关，用$E_{str}^s$编码源域上图片的结构信息，用$E_{str}^t$编码目标域上图片的结构信息。然后将源域上的appearance信息$v_{s(i)}$和目标域上的structure信息$t_{t(j)}$结合经过$D^{t}$得到假图$x_{t(j)}^{s(i)}(上标表示app哪里来，下标表示str哪里来)，这张图的语义信息应该接近$x_{s(i)}$而结构信息应该接近$x_{t(j)}$，对目标域上的appearance信息$v_{s(i)}$和源域上的structure信息$t_{t(j)}$做同样操作，然后再将假图的appearance和structure分离，再交换，变换回输入的图，然后就可以用pixel-level的L1 loss约束训练。</p>
<h3 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h3><p>我们希望$E_{app}$提取到的特征$v_{s(i)}$是id相关的特征，所以用CE loss来约束（注意目标域上的图片没有id，但是可以用聚类得到），同时为了解耦合，所以用$D_{dom}$来判断$v_{s(i)}$是来自于哪个域。对于生成的假图$x_{t(j)}^{s(i)}，用$D_{img}$来判断是真图还是假图（常规的GAN loss）,将这张假图输入到$E_{app}$提取到的特征应该和$x_{s(i)}$输入到$E_{app}$提取到的特征同属一个类别，也用CE loss约束训练，通过再次交换appearance和structure可以变换回原图，用pixel-level的L1 loss约束训练。各loss形式如下：</p>
<h4 id="循环一致性loss"><a href="#循环一致性loss" class="headerlink" title="循环一致性loss"></a>循环一致性loss</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012042630.png"></p>
<h4 id="源域图片CE-loss"><a href="#源域图片CE-loss" class="headerlink" title="源域图片CE loss"></a>源域图片CE loss</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012042807.png"><br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012042946.png"></p>
<h4 id="判断图片是真还是假"><a href="#判断图片是真还是假" class="headerlink" title="判断图片是真还是假"></a>判断图片是真还是假</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012043016.png"></p>
<h4 id="判断图片是属于哪个域"><a href="#判断图片是属于哪个域" class="headerlink" title="判断图片是属于哪个域"></a>判断图片是属于哪个域</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012043047.png"></p>
<h4 id="目标域图片CE-loss"><a href="#目标域图片CE-loss" class="headerlink" title="目标域图片CE loss"></a>目标域图片CE loss</h4><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012043113.png"><br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012043155.png"></p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012043402.png"><br>性能真高~</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>List逆序的两者方式</title>
    <url>/2020/09/28/List%E9%80%86%E5%BA%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>reverse</li>
<li>切片</li>
</ul>
<a id="more"></a>

<h3 id="第一种方式-list-reverse"><a href="#第一种方式-list-reverse" class="headerlink" title="第一种方式 list.reverse()"></a>第一种方式 list.reverse()</h3><p>Python 的 list.reverse() 方法，会直接在原来的列表里面将元素进行逆序排列，<strong>不需要创建新的副本</strong>用于存储结果。调用 list.reverse() 的返回值是 None ，它逆序的结果<strong>直接体现在原来的列表</strong>里面。</p>
<h3 id="第二种方式-使用切片-1"><a href="#第二种方式-使用切片-1" class="headerlink" title="第二种方式 使用切片 [::-1]"></a>第二种方式 使用切片 [::-1]</h3><p>Python 的列表有一个特性叫做切片，可以将它看作是方括号（ [ ] ）使用的扩展。使用方式为<code>mylist[start:end:step]</code>上面的操作表示取 mylist 的第 start 个（列表索引从 0 开始）到第 end 个元素（不包括第 end 个），其中每隔 step 个（默认 1 ）取一个</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab相机标定</title>
    <url>/2020/10/12/Matlab%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>得到相机的内参矩阵A、外参矩阵[R|T]、畸变系数[k1,k2,k3,<del>,p1,p2,</del>]。</li>
<li>通过内外参数矩阵可以得到2维像素坐标与3维空间坐标的对应关系。（可以用来做无线大数据）<a id="more"></a>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="四个坐标系"><a href="#四个坐标系" class="headerlink" title="四个坐标系"></a>四个坐标系</h3></li>
</ol>
<ul>
<li>世界坐标系(world coordinate system)：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入，比如经纬度就可以作为世界坐标系。</li>
<li>相机坐标系(camera coordinate system)：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。</li>
<li>图像坐标系(image coordinate system)：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。</li>
<li>像素坐标系(pixel coordinate system)：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。</li>
</ul>
<h3 id="从世界坐标到相机坐标（3D-gt-3D）"><a href="#从世界坐标到相机坐标（3D-gt-3D）" class="headerlink" title="从世界坐标到相机坐标（3D-&gt;3D）"></a>从世界坐标到相机坐标（3D-&gt;3D）</h3><p>世界坐标$(X_w, Y_w, Z_w)$到相机坐标$(X_c, Y_c, Z_c)$为刚体变换，可以用旋转矩阵$R_{3{\times}3}$和平移向量$T_{3{\times}1}$来表示。两者之间的关系为<br><img src="https://s1.ax1x.com/2020/10/12/02Y2zn.png"></p>
<h3 id="从相机坐标到图像坐标（3D-gt-2D）"><a href="#从相机坐标到图像坐标（3D-gt-2D）" class="headerlink" title="从相机坐标到图像坐标（3D-&gt;2D）"></a>从相机坐标到图像坐标（3D-&gt;2D）</h3><p>相机坐标$(X_c, Y_c, Z_c)$到图像坐标$(x, y)$为透视投影过程，进行了从三维坐标到二维坐标的转换，可以采用小孔成像模型也可以用鱼眼模型。<br><img src="https://s1.ax1x.com/2020/10/12/02Y7i4.png"></p>
<p>坐标关系为<br><img src="https://s1.ax1x.com/2020/10/12/02tSoD.png"></p>
<h3 id="从图像坐标到像素坐标（2D-gt-2D）"><a href="#从图像坐标到像素坐标（2D-gt-2D）" class="headerlink" title="从图像坐标到像素坐标（2D-&gt;2D）"></a>从图像坐标到像素坐标（2D-&gt;2D）</h3><p>相机坐标$(x, y)$到图像坐标$(u, v)$为空间离散化和原点平移。两者关系为<br><img src="https://s1.ax1x.com/2020/10/12/02tPWd.png"></p>
<p>由于定义的像素坐标系原点与图像坐标系原点不重合，假设像素坐标系原点在图像坐标系下的坐标为$(u_0, v_0)$，每个像素点在图像坐标系x轴、y轴方向的尺寸为：$d_x, d_y$（假设传感器长宽为$a{\times}b$，图像分辨率为$m{\times}n$，则$d_x=\frac{a}{m}, d_y=\frac{b}{n}$）且像点在实际图像坐标系下的坐标为$(x, y)$，于是可得到像点在像素坐标系下的坐标为：<br><img src="https://s1.ax1x.com/2020/10/12/02tew8.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s1.ax1x.com/2020/10/12/02tuFg.png"></p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>1、打印一张棋盘格，把它贴在一个平面上，作为标定物。<br>2、通过调整标定物或摄像机的方向，为标定物拍摄一些不同方向的照片。<br>3、从照片中提取棋盘格角点。<br>4、估算理想无畸变的情况下，五个内参和六个外参。<br>5、应用最小二乘法估算实际存在径向畸变下的畸变系数。<br>6、极大似然法，优化估计，提升估计精度</p>
<h3 id="制作棋盘格"><a href="#制作棋盘格" class="headerlink" title="制作棋盘格"></a>制作棋盘格</h3><p><img src="https://s1.ax1x.com/2020/10/12/02tYwT.jpg"></p>
<h3 id="导入matlab"><a href="#导入matlab" class="headerlink" title="导入matlab"></a>导入matlab</h3><p>选择红框中的app<br><img src="https://s1.ax1x.com/2020/10/12/02tUkF.png"><br>点击红框中的add images导入预先拍摄好的图片<br><img src="https://s1.ax1x.com/2020/10/12/02tdfJ.png"><br>输入棋盘格的间距，我的棋盘格是25mm<br><img src="https://s1.ax1x.com/2020/10/12/02t0p9.png"></p>
<h3 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h3><p>查看标定结果<br><img src="https://s1.ax1x.com/2020/10/12/02tTnP.png"></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><img src="https://s1.ax1x.com/2020/10/12/02tv1s.png"></p>
<p><img src="https://s1.ax1x.com/2020/10/12/02tzXq.png"></p>
<h2 id="棋盘格文件下载"><a href="#棋盘格文件下载" class="headerlink" title="棋盘格文件下载"></a>棋盘格文件下载</h2><ul>
<li><a href="https://download.csdn.net/download/weixin_41349117/11846674">https://download.csdn.net/download/weixin_41349117/11846674</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.bilibili.com/video/BV18J411U7DS">https://www.bilibili.com/video/BV18J411U7DS</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>SLAM</tag>
        <tag>无线大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Python修饰器</title>
    <url>/2020/10/03/Python%E4%BF%AE%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在原有函数的基础上增加新的功能</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>给函数增加一个统计运行时间的功能</p>
<a id="more"></a>
<h3 id="最简单的做法"><a href="#最简单的做法" class="headerlink" title="最简单的做法"></a>最简单的做法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAdd</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 因为运行速度太快，所以增加2s的休眠时间</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">startTime = time.time()</span><br><span class="line">myAdd(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">totalTime = time.time() - startTime</span><br><span class="line">print(<span class="string">&#x27;运行时间为：&#x27;</span>, totalTime)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">运行时间为： <span class="number">2.0006561279296875</span></span><br></pre></td></tr></table></figure>
<p>对于每个函数都要写相同的语句，很麻烦，可以用函数的方式来代替</p>
<h3 id="用函数的形式"><a href="#用函数的形式" class="headerlink" title="用函数的形式"></a>用函数的形式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAdd</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 因为运行速度太快，所以增加2s的休眠时间</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    startTime = time.time()</span><br><span class="line">    func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    totalTime = time.time() - startTime</span><br><span class="line">    <span class="keyword">return</span> totalTime</span><br><span class="line">print(<span class="string">&#x27;运行时间为：&#x27;</span>, calculateTime(myAdd))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">运行时间为： <span class="number">2.000053644180298</span></span><br></pre></td></tr></table></figure>
<p>但是这改变了函数的调用方式，本来调用myAdd，现在调用calculateTime</p>
<h3 id="不改变函数调用方式"><a href="#不改变函数调用方式" class="headerlink" title="不改变函数调用方式"></a>不改变函数调用方式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAdd</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 因为运行速度太快，所以增加2s的休眠时间</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        startTime = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        totalTime = time.time() - startTime</span><br><span class="line">        <span class="keyword">return</span> totalTime</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">myAdd = calculateTime(myAdd)</span><br><span class="line">print(<span class="string">&#x27;运行时间为：&#x27;</span>, myAdd(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">运行时间为： <span class="number">2.0000948905944824</span></span><br></pre></td></tr></table></figure>
<p>需要增加myAdd = calculateTime(myAdd)这行代码，能否用更加简洁的形式代替？语法糖！</p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        startTime = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        totalTime = time.time() - startTime</span><br><span class="line">        <span class="keyword">return</span> totalTime</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@calculateTime # myAdd = calculateTime(myAdd)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAdd</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 因为运行速度太快，所以增加2s的休眠时间</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;运行时间为：&#x27;</span>, myAdd(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">运行时间为： <span class="number">2.0005946159362793</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python偏函数</title>
    <url>/2020/10/01/Python%E5%81%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>functools.partial的作用就是把一个函数的某些参数给固定住（设置默认值），返回一个新函数，调用这个函数会更加简单</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % y</span><br><span class="line"></span><br><span class="line">mod100 = partial(mod, <span class="number">100</span>)</span><br><span class="line">print(mod100(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">int2 = partial(int,base=<span class="number">2</span>)</span><br><span class="line">print(int2(<span class="string">&#x27;0101010010101&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2709</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python可变参数</title>
    <url>/2020/10/01/Python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>如果用户在声明参数时不能确定需要使用多少个参数，就使用可变参数，可变参数无需命名。</li>
<li>加了*号的变量名可以存放所有未命名的变量，比如*args</li>
<li>加了**号的变量名可以存放一个字典对象，比如**kwargs</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;func:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(<span class="string">&#x27;undefined arg:&#x27;</span>, arg)</span><br><span class="line">    print(<span class="string">&#x27;---&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> kwargs:</span><br><span class="line">        print(<span class="string">&#x27;undefined key=&#123;&#125;, value=&#123;&#125;&#x27;</span>.format(k, kwargs[k]))</span><br><span class="line">    print(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;apple&#x27;</span>,worda=<span class="string">&#x27;a&#x27;</span>, wordb=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python可迭代对象</title>
    <url>/2020/09/28/Python%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="可迭代对象是什么？"><a href="#可迭代对象是什么？" class="headerlink" title="可迭代对象是什么？"></a>可迭代对象是什么？</h3><p>凡是定义了<code>__iter__</code>和<code>__next__</code>方法的类所实例化出来的对象都是可迭代对象。</p>
<a id="more"></a>

<h3 id="有哪些内置可迭代对象？"><a href="#有哪些内置可迭代对象？" class="headerlink" title="有哪些内置可迭代对象？"></a>有哪些内置可迭代对象？</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>,dict(<span class="built_in">keys</span>(),<span class="built_in">values</span>(),<span class="built_in">items</span>()),tuple,str,<span class="keyword">set</span>,<span class="built_in">range</span></span><br></pre></td></tr></table></figure>

<h3 id="如何判断一个对象是否是可迭代对象"><a href="#如何判断一个对象是否是可迭代对象" class="headerlink" title="如何判断一个对象是否是可迭代对象"></a>如何判断一个对象是否是可迭代对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;__iter__&#x27;</span> <span class="keyword">in</span> dir(obj):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python处理json文件</title>
    <url>/2020/10/03/Python%E5%A4%84%E7%90%86json%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。<br>我们可以使用Python 语言来编码和解码 JSON 对象。</p>
<a id="more"></a>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入 JSON 数据 </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    json.dump(data, f) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据 </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    data = json.load(f)</span><br></pre></td></tr></table></figure>
<p>另外还有</p>
<ul>
<li>json.dumps(): 对数据进行编码。</li>
<li>json.loads(): 对数据进行解码。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python处理pickle文件</title>
    <url>/2020/10/03/Python%E5%A4%84%E7%90%86pickle%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>python的pickle模块实现了基本的数据序列和反序列化。<br>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。<br>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p>
<a id="more"></a>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = &#123;<span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">    pickle.dump(data, f)</span><br></pre></td></tr></table></figure>

<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pickle.load(f)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python处理文件</title>
    <url>/2020/10/03/Python%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>打开关闭文件</li>
<li>读写文件<a id="more"></a>
<h2 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(path, mode)</span><br></pre></td></tr></table></figure></li>
<li>path为文件目录</li>
<li>mode为打开模式，常用的有’r’,’w’,’rb’,’wb’,’a’,’ab’<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path, mode) <span class="keyword">as</span> f:</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.read(size)</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">君不见，黄河之水天上来，奔流到海不复回。</span><br><span class="line">君不见，高堂明镜悲白发，朝如青丝暮成雪。</span><br><span class="line">人生得意须尽欢，莫使金樽空对月。</span><br><span class="line">天生我材必有用，千金散尽还复来。</span><br><span class="line">烹羊宰牛且为乐，会须一饮三百杯。</span><br><span class="line">岑夫子，丹丘生，将进酒，杯莫停。</span><br><span class="line">与君歌一曲，请君为我倾耳听。</span><br><span class="line">钟鼓馔玉不足贵，但愿长醉不复醒。</span><br><span class="line">古来圣贤皆寂寞，惟有饮者留其名。</span><br><span class="line">陈王昔时宴平乐，斗酒十千恣欢谑。</span><br><span class="line">主人何为言少钱，径须沽取对君酌。</span><br><span class="line">五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</span><br></pre></td></tr></table></figure>
<h4 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h4><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.readline(size)</span><br></pre></td></tr></table></figure>
<p>说明：<br>按行读文件，返回为文件的一行内容<br>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readline()</span><br><span class="line">    print(data)</span><br><span class="line">    data = f.readline()</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">君不见，黄河之水天上来，奔流到海不复回。</span><br><span class="line"></span><br><span class="line">君不见，高堂明镜悲白发，朝如青丝暮成雪。</span><br></pre></td></tr></table></figure>
<h4 id="readlines"><a href="#readlines" class="headerlink" title="readlines()"></a>readlines()</h4><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.readline(size)</span><br></pre></td></tr></table></figure>
<p>说明：<br>按行读整个文件，返回为一个list，这个list包含所有内容<br>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        print(line.strip())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">君不见，黄河之水天上来，奔流到海不复回。</span><br><span class="line">君不见，高堂明镜悲白发，朝如青丝暮成雪。</span><br><span class="line">人生得意须尽欢，莫使金樽空对月。</span><br><span class="line">天生我材必有用，千金散尽还复来。</span><br><span class="line">烹羊宰牛且为乐，会须一饮三百杯。</span><br><span class="line">岑夫子，丹丘生，将进酒，杯莫停。</span><br><span class="line">与君歌一曲，请君为我倾耳听。</span><br><span class="line">钟鼓馔玉不足贵，但愿长醉不复醒。</span><br><span class="line">古来圣贤皆寂寞，惟有饮者留其名。</span><br><span class="line">陈王昔时宴平乐，斗酒十千恣欢谑。</span><br><span class="line">主人何为言少钱，径须沽取对君酌。</span><br><span class="line">五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</span><br></pre></td></tr></table></figure>

<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.write(str)</span><br></pre></td></tr></table></figure>
<p>说明：<br>写文件，参数必须时字符串，不能为list或者tuple<br>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ss = <span class="string">&#x27;春花秋月何时了？往事知多少。&#x27;</span></span><br><span class="line">    f.write(ss)</span><br></pre></td></tr></table></figure>
<p>file文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">春花秋月何时了？往事知多少。</span><br></pre></td></tr></table></figure>
<h4 id="writelines"><a href="#writelines" class="headerlink" title="writelines()"></a>writelines()</h4><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.writelines([str])</span><br></pre></td></tr></table></figure>
<p>说明：<br>写文件，参数为list或者tuple，注意需要手动换行<br>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ss = <span class="string">&#x27;春花秋月何时了？往事知多少。小楼昨夜又东风，故国不堪回首月明中。\n&#x27;</span>,<span class="string">&#x27;雕栏玉砌应犹在，只是朱颜改。问君能有几多愁？恰似一江春水向东流。\n&#x27;</span></span><br><span class="line">    f.writelines(ss)</span><br></pre></td></tr></table></figure>
<p>file文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">春花秋月何时了？往事知多少。小楼昨夜又东风，故国不堪回首月明中。</span><br><span class="line">雕栏玉砌应犹在，只是朱颜改。问君能有几多愁？恰似一江春水向东流。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程</title>
    <url>/2020/09/28/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ol>
<li>进程、线程是什么？为什么要用多线程？</li>
<li>如何创建多线程？</li>
<li>主线程、父线程、子线程</li>
<li>阻塞线程</li>
<li>线程同步</li>
</ol>
<a id="more"></a>

<h3 id="进程、线程是什么？为什么要用多线程？"><a href="#进程、线程是什么？为什么要用多线程？" class="headerlink" title="进程、线程是什么？为什么要用多线程？"></a>进程、线程是什么？为什么要用多线程？</h3><p>官话：<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p>
<h3 id="如何创建多线程？"><a href="#如何创建多线程？" class="headerlink" title="如何创建多线程？"></a>如何创建多线程？</h3><p>Python3实现多线程的是threading模块，首先导入模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure>

<p>Python支持创建多线程：</p>
<ul>
<li>通过threading.Thread()创建</li>
<li>通过继承threading.Thread类创建</li>
<li>前者直接用Thread类实例化一个线程对象，后者继承Thread类，改写run方法，实现不同的功能</li>
</ul>
<h4 id="用threading-Thread-创建"><a href="#用threading-Thread-创建" class="headerlink" title="用threading.Thread()创建"></a>用threading.Thread()创建</h4><p>Thread()语法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>, args=(), kwargs=(), *, daemon=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>group:一般为None</li>
<li>target:线程调用的对象，就是目标函数</li>
<li>name:给线程起名字，默认是Target-x，初始x=1</li>
<li>args:函数实参，传入元组</li>
<li>kwargs:为目标函数传入关键字参数，传入字典</li>
<li>daemin:用来设置线程是否随主线程的退出而退出</li>
</ul>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(x, y):</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(name=<span class="string">&#x27;t1&#x27;</span>, target=test, args=(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">thread2 = threading.Thread(name=<span class="string">&#x27;t2&#x27;</span>, target=test, args=(<span class="number">1</span>, <span class="number">20</span>))</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">print(<span class="string">&#x27;线程结束了&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">线程结束了</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">38</span></span><br><span class="line"></span><br><span class="line"><span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>

<h4 id="继承threading-Thread类创建"><a href="#继承threading-Thread类创建" class="headerlink" title="继承threading.Thread类创建"></a>继承threading.Thread类创建</h4><p>定义一个类继承threading.Thread，然后重写父类的run()方法，会在线程启动(start())时自动执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        super(MyThread, self).__init__()</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.a, self.b):</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">thread1 = MyThread(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">thread2 = MyThread(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">print(<span class="string">&#x27;线程结束了&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>线程结束了</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>

<h3 id="主线程、父线程、子线程"><a href="#主线程、父线程、子线程" class="headerlink" title="主线程、父线程、子线程"></a>主线程、父线程、子线程</h3><ul>
<li>主线程=父线程</li>
<li>如果线程A中启动了线程B，那么A是B的父线程，B是A的子线程</li>
<li>daemon属性，当daemon为True时，主线程结束之后子线程立即停止；当daemon为False时，主线程结束之后，子线程可继续执行</li>
</ul>
<h3 id="阻塞线程"><a href="#阻塞线程" class="headerlink" title="阻塞线程"></a>阻塞线程</h3><p>join()方法，可以阻塞线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">join(timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>timeout参数指定阻塞时间，如果没有设置就一直等待，直到被调用的线程完成为止，注意join不能与start在循环里连用</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>在访问共享资源的时候，不同线程会冲突，看下面的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        x += <span class="number">10</span></span><br><span class="line">        print(self.name, x)</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">threadList = [MyThread() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> threadList:</span><br><span class="line">    i.start()</span><br><span class="line">print(<span class="string">&#x27;主线程结束了&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Thread<span class="number">-1</span> <span class="number">10</span>Thread<span class="number">-2</span></span><br><span class="line"> <span class="number">20</span></span><br><span class="line">Thread<span class="number">-3</span> Thread<span class="number">-4</span> <span class="number">40</span></span><br><span class="line"><span class="number">30</span>Thread<span class="number">-5</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line">主线程结束了</span><br></pre></td></tr></table></figure>

<p>解决方法为加锁</p>
<h4 id="Lock与Rlock"><a href="#Lock与Rlock" class="headerlink" title="Lock与Rlock"></a>Lock与Rlock</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用Lock加锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        lock.acquire()</span><br><span class="line">        x += <span class="number">10</span></span><br><span class="line">        print(self.name, x)</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">threadList = [MyThread() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> threadList:</span><br><span class="line">    i.start()</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Thread<span class="number">-1</span> <span class="number">10</span></span><br><span class="line">Thread<span class="number">-2</span> <span class="number">20</span></span><br><span class="line">Thread<span class="number">-3</span> <span class="number">30</span></span><br><span class="line">Thread<span class="number">-4</span> <span class="number">40</span></span><br><span class="line">Thread<span class="number">-5</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字符串前面的u,r,b含义</title>
    <url>/2020/09/28/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E7%9A%84u-r-b%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul>
<li>加r是取消转义，保留原始字符串</li>
<li>加u是采用Unicode编码</li>
<li>加b是表示后面的字符串是bytes类型，用于网络编程中收发数据</li>
</ul>
<a id="more"></a>

<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>1、字符串前加 u<br>例：u”我是含有中文字符组成的字符串。”<br>作用：后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。 </p>
<p>2、字符串前加 r<br>例：r”\n\n\n\n”　　# 表示一个普通生字符串 \n\n\n\n，而不表示换行了。<br>作用：去掉反斜杠的转义机制。（特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。 ）<br>应用：常用于正则表达式，对应着re模块。 </p>
<p>3、字符串前加 b<br>例: response = b’<h1>Hello World!</h1>‘     # b’ ‘ 表示这是一个 bytes 对象<br>作用：b” “前缀表示：后面字符串是bytes 类型。<br>应用：网络编程中，服务器和浏览器只认bytes 类型数据。如：send 函数的参数和 recv 函数的返回值都是 bytes 类型<br>附：在 Python3 中，bytes 和 str 的互相转换方式是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python异常处理</title>
    <url>/2020/09/28/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol>
<li>看懂异常信息</li>
<li>捕获异常信息</li>
<li>多重异常处理</li>
<li>自定义的异常信息</li>
</ol>
<a id="more"></a>

<h3 id="看懂异常信息"><a href="#看懂异常信息" class="headerlink" title="看懂异常信息"></a>看懂异常信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcnum</span>(<span class="params">li, divnum</span>):</span></span><br><span class="line">    newList = [divnum / one <span class="keyword">for</span>  one <span class="keyword">in</span> li]</span><br><span class="line">    <span class="keyword">return</span> newList</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    calcnum([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/Users/shensanjing/opt/anaconda3/envs/python38/bin/python /Users/shensanjing/Documents/pycharm/testfile/main.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/shensanjing/Documents/pycharm/testfile/main.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    test2()</span><br><span class="line">  File <span class="string">&quot;/Users/shensanjing/Documents/pycharm/testfile/main.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> test2</span><br><span class="line">    test()</span><br><span class="line">  File <span class="string">&quot;/Users/shensanjing/Documents/pycharm/testfile/main.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> test</span><br><span class="line">    calcnum([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>], <span class="number">3</span>)</span><br><span class="line">  File <span class="string">&quot;/Users/shensanjing/Documents/pycharm/testfile/main.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> calcnum</span><br><span class="line">    newList = [divnum / one <span class="keyword">for</span>  one <span class="keyword">in</span> li]</span><br><span class="line">  File <span class="string">&quot;/Users/shensanjing/Documents/pycharm/testfile/main.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;listcomp&gt;</span><br><span class="line">    newList = [divnum / one <span class="keyword">for</span>  one <span class="keyword">in</span> li]</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<ul>
<li>信息头</li>
<li>出错位置：自下而上传播错误信息，直到找到异常处理代码，或传播到顶层，所以如果想要知道哪儿出错了，应该从后往前找</li>
<li>异常信息：<strong>ZeroDivisionError</strong>除零错</li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcnum</span>(<span class="params">li, divnum</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        newList = [divnum / one <span class="keyword">for</span>  one <span class="keyword">in</span> li]</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">&#x27;列表中有0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    calcnum([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">列表中有<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>不仅可以在calnum函数中捕获异常，还可以在test，test2函数中捕获，因为异常传播方向是calnum-&gt;test-&gt;test2在任何一个地方都能捕获到<strong>ZeroDivisionError</strong></p>
<h3 id="多重异常处理"><a href="#多重异常处理" class="headerlink" title="多重异常处理"></a>多重异常处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statements1</span><br><span class="line"><span class="keyword">except</span> (ExceptionType1, ExceptionType2):</span><br><span class="line">    statements2</span><br><span class="line"><span class="keyword">except</span> (ExceptionType3, ExceptionType4):</span><br><span class="line">    statements3</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    statements4</span><br></pre></td></tr></table></figure>

<ul>
<li>except后面可以接多个异常</li>
<li>可以有多个except</li>
<li>except后面可以不接异常，表示如果不满足ExceptionType1…4则执行statements4</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statements1</span><br><span class="line"><span class="keyword">except</span> (ExceptionType1, ExceptionType2):</span><br><span class="line">    statements2</span><br><span class="line"><span class="keyword">except</span> (ExceptionType3, ExceptionType4):</span><br><span class="line">    statements3</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    statements4</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statements5</span><br></pre></td></tr></table></figure>

<ul>
<li>只有statements1没有异常，才执行statements5</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statements1</span><br><span class="line"><span class="keyword">except</span> (ExceptionType1, ExceptionType2):</span><br><span class="line">    statements2</span><br><span class="line"><span class="keyword">except</span> (ExceptionType3, ExceptionType4):</span><br><span class="line">    statements3</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    statements4</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    statements5</span><br></pre></td></tr></table></figure>

<ul>
<li>无论statements1有没有异常，都执行statements5</li>
</ul>
<h3 id="异常参数处理"><a href="#异常参数处理" class="headerlink" title="异常参数处理"></a>异常参数处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    statements1</span><br><span class="line"><span class="keyword">except</span> (ExceptionType1, ExceptionType2) <span class="keyword">as</span> e:</span><br><span class="line">    statements2</span><br><span class="line"><span class="keyword">except</span> (ExceptionType3, ExceptionType4):</span><br><span class="line">    statements3</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    statements4</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    statements5</span><br></pre></td></tr></table></figure>

<ul>
<li>e中存有异常信息</li>
</ul>
<h3 id="内置异常类型"><a href="#内置异常类型" class="headerlink" title="内置异常类型"></a>内置异常类型</h3><p>比较常用的有：</p>
<ul>
<li>IndexError：访问的list元素不存在<img src="en-resource://database/1283:1" alt="1b25589eac20e6966686832075716f37.png"></li>
<li>KeyError: 访问的字典键不存在</li>
<li>IOError: 尝试读写一个不存在的文件，或者其他IO错误</li>
<li>NameError: 访问不存在的变量</li>
<li>TypeError: 对一个类型使用不支持的操作，比如字符串除法</li>
<li>AttributeError: 访问一个对象不存在的属性</li>
<li>ZeroDivisionError: 除0错</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><ol>
<li>后接实例化对象<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">&#x27;aa&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>后接类<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自定义异常类型"><a href="#自定义异常类型" class="headerlink" title="自定义异常类型"></a>自定义异常类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.value)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;My exception occurred, value:&#x27;</span>, e.value)</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">My exception occurred, value: <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python正则表达式与re模块</title>
    <url>/2020/09/28/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8Ere%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>正则表达式元字符与语法</li>
<li>re模块的简单使用</li>
</ul>
<a id="more"></a>

<h3 id="正则表达式元字符与语法"><a href="#正则表达式元字符与语法" class="headerlink" title="正则表达式元字符与语法"></a>正则表达式元字符与语法</h3><p>建议google，常用的有……，常用的太多了，还是google吧</p>
<h3 id="re模块的简单使用"><a href="#re模块的简单使用" class="headerlink" title="re模块的简单使用"></a>re模块的简单使用</h3><h4 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">str = <span class="string">&#x27;abcbccbabccccb&#x27;</span></span><br><span class="line"></span><br><span class="line">match = re.search(pattern, str)</span><br><span class="line"></span><br><span class="line">print(type(match.group()), match.group())</span><br></pre></td></tr></table></figure>
<h4 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile"></a>re.compile</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">str = <span class="string">&#x27;abcbccbabccccb&#x27;</span></span><br><span class="line"></span><br><span class="line">match = pattern.search(str)</span><br><span class="line"></span><br><span class="line">print(type(match.group()), match.group())</span><br></pre></td></tr></table></figure>
<p>通过编译，返回一个对象模式，能够提高执行效率</p>
<h4 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">str = <span class="string">&#x27;abcbccbabccccb&#x27;</span></span><br><span class="line"></span><br><span class="line">match = pattern.findall(str)</span><br><span class="line"></span><br><span class="line">print(type(match), match)</span><br></pre></td></tr></table></figure>
<p>找到所有匹配的子串</p>
<h4 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">&#x27;\d+&#x27;</span>)</span><br><span class="line">str = <span class="string">&#x27;abcb1ccba3bccc5cb&#x27;</span></span><br><span class="line"></span><br><span class="line">match = pattern.split(str)</span><br><span class="line"></span><br><span class="line">print(type(match), match)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动给数字前面补0</title>
    <url>/2020/09/30/Python%E8%87%AA%E5%8A%A8%E7%BB%99%E6%95%B0%E5%AD%97%E5%89%8D%E9%9D%A2%E8%A1%A50/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>zfill方法</li>
<li>格式化</li>
</ul>
<a id="more"></a>

<h3 id="zfill方法"><a href="#zfill方法" class="headerlink" title="zfill方法"></a>zfill方法</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">n</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="attr">s</span> = n.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="attr">s</span> == &#x27;<span class="number">00123</span>&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>有两种方式</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">n = <span class="number">123</span></span><br><span class="line"># <span class="number">0</span>表示补<span class="number">0</span>，<span class="number">5</span>表示补全之后占<span class="number">5</span>位</span><br><span class="line">s = &#x27;%<span class="number">05</span>d&#x27; % n</span><br><span class="line">assert s == &#x27;<span class="number">00123</span>&#x27;</span><br></pre></td></tr></table></figure>
<p>也可以用format</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">n</span> = <span class="number">123</span></span><br><span class="line"><span class="comment"># 不要忘记:</span></span><br><span class="line"><span class="attr">s</span> = &#x27;&#123;:<span class="number">05</span>d&#125;&#x27;.format(n)</span><br><span class="line"><span class="keyword">assert</span> <span class="attr">s</span> == &#x27;<span class="number">00123</span>&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python生成器</title>
    <url>/2020/10/03/Python%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。<br>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。<br>调用一个生成器函数，返回的是一个迭代器对象。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用yield关键字</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = fibonacci(<span class="number">5</span>)</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:/Users/64547/PycharmProjects/py1/test2.py&quot;</span>, line <span class="number">17</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(next(f))</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python统计类实例化了多少对象</title>
    <url>/2020/10/02/Python%E7%BB%9F%E8%AE%A1%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%BA%86%E5%A4%9A%E5%B0%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>掌握类变量和实例变量的定义</li>
<li>掌握类变量和实例变量的引用</li>
</ul>
<a id="more"></a>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>先看一组例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(Student.count)</span><br><span class="line">print(stu1.count)</span><br><span class="line">print(stu2.count)</span><br><span class="line">print(stu3.count)</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>分析：<br>因为计数器前是self，所以这是个实例对象，不在类之间共享，应该将self改成类名Student</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        <span class="comment"># self.count += 1</span></span><br><span class="line">        Student.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(Student.count)</span><br><span class="line">print(stu1.count)</span><br><span class="line">print(stu2.count)</span><br><span class="line">print(stu3.count)</span><br><span class="line">print(stu1.__dict__)</span><br><span class="line">print(stu2.__dict__)</span><br><span class="line">print(stu3.__dict__)</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;alex&#x27;</span>, <span class="attr">&#x27;age&#x27;:</span> <span class="string">&#x27;male&#x27;</span>, <span class="attr">&#x27;sex&#x27;:</span> <span class="number">38</span>&#125;</span><br><span class="line">&#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;jinxin&#x27;</span>, <span class="attr">&#x27;age&#x27;:</span> <span class="string">&#x27;female&#x27;</span>, <span class="attr">&#x27;sex&#x27;:</span> <span class="number">78</span>&#125;</span><br><span class="line">&#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;Egon&#x27;</span>, <span class="attr">&#x27;age&#x27;:</span> <span class="string">&#x27;male&#x27;</span>, <span class="attr">&#x27;sex&#x27;:</span> <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类变量与实例变量的定义"><a href="#类变量与实例变量的定义" class="headerlink" title="类变量与实例变量的定义"></a>类变量与实例变量的定义</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    <span class="comment"># 定义类变量</span></span><br><span class="line">    define classVar</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, *args, **kwargs)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 定义实例变量</span></span><br><span class="line">        define <span class="keyword">self</span>.instanceVar</span><br></pre></td></tr></table></figure>

<h2 id="类变量和实例变量的引用"><a href="#类变量和实例变量的引用" class="headerlink" title="类变量和实例变量的引用"></a>类变量和实例变量的引用</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>无论在在类中用还是在类外都用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ClassName.classVar</span><br></pre></td></tr></table></figure>
<p>来表示</p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>在类中用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.instanceVar</span><br></pre></td></tr></table></figure>
<p>在类外用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">instanceName.instanceVar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-Training With Progressive Augmentation for Unsupervised Cross-Domain Person Re-Identification论文笔记</title>
    <url>/2020/08/27/Self-Training-With-Progressive-Augmentation-for-Unsupervised-Cross-Domain-Person-Re-Identification%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Xinyu Zhang Jiewei Cao</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>ICCV 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>现有的pseudo label estimation高度依赖于聚类结果，所以需要一种渐进的方式来逐步学到可信的伪标签。<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li>提出一种self-train的渐近式的framwork，总共分成两步conservative stage和promoting stage，在conservative stage用triplet loss来优化网络参数得到相对可信的标签，在promoting stage用cross entropy loss充分利用全局信息。</li>
<li>提出一种ranking-based triplet loss，这个loss不依赖聚类产生的伪标签。而是利用特征相似性。</li>
</ul>
<a id="more"></a>

<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://img-blog.csdnimg.cn/20191210222004400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><img src="https://img-blog.csdnimg.cn/20191210222137389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Framework-Overview"><a href="#Framework-Overview" class="headerlink" title="Framework Overview"></a>Framework Overview</h2><ol>
<li>首先用source domian上带标签的数据来初始化CNN模型M，用模型M提取target domain上图片特征F。</li>
<li>在conservative stage用HDBSCAN聚类算法得到相对可信的子类Tu，用CTL(clustering-based triplet loss)和RTL(ranking-based triplet loss)优化网络参数。前者依赖于子类Tu，后者依赖于特征相似性。用优化后的网络提取特征得到Fu。</li>
<li>在promoting stage用HDBSCAN聚类算法对新的Fu特征聚类，将cluster的个数是为ID个数，用cross entropy loss计算损失，更新网络参数。</li>
</ol>
<h2 id="Conservative-Stage"><a href="#Conservative-Stage" class="headerlink" title="Conservative Stage"></a>Conservative Stage</h2><p>主要为两个损失函数CTL和RTL，都很直白。</p>
<h3 id="CTL"><a href="#CTL" class="headerlink" title="CTL"></a>CTL</h3><p>CTL将每个cluster视为一类，每次取P个cluster，每个cluster取K张图的特征，然后用hard triplet计算loss，损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20191211100117776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="RTL"><a href="#RTL" class="headerlink" title="RTL"></a>RTL</h3><p>RTL将每张图根据特征相似性(Jaccard 距离)对所有图排序，取$[ 1, \eta]$为positive sample，取$(\eta, 2\eta]$为negative sample(为啥不取的更加远一些-_-)损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20191211100900404.png" alt="在这里插入图片描述"><br>$P_p$和$P_n$分别为$x_p$和$x_n$相对于$x_a$的ranking位置，值得注意的是这个一个soft margin，$x_p$和$x_n$相距越近margin应该越小，符合常理。</p>
<h2 id="Promoting-Stage"><a href="#Promoting-Stage" class="headerlink" title="Promoting Stage"></a>Promoting Stage</h2><p>只用三元组损失函数容易陷入局部最优解，所以依然需要cross entropy loss来充分利用全局信息。损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20191211152657967.png" alt="在这里插入图片描述"><br>$\hat{y_i}$为$x_i$的伪标签，这个伪标签由HDBSCAN对Fu(模型经过CTL和RTL优化之后重新对target domain上的图像提取特征)聚类得到，C为cluster的数量。值得注意的是$W_c^T$用每一类的特征均值做初始化，因为分类器每一类的参数实际上是这一类的模板，所以这么做可以加快收敛。</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Ablation-Study"><a href="#Ablation-Study" class="headerlink" title="Ablation Study"></a>Ablation Study</h3><p><img src="https://img-blog.csdnimg.cn/20191211153713198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="不同的聚类方法"><a href="#不同的聚类方法" class="headerlink" title="不同的聚类方法"></a>不同的聚类方法</h3><p><img src="https://img-blog.csdnimg.cn/20191211154307135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="SOTA"><a href="#SOTA" class="headerlink" title="SOTA"></a>SOTA</h3><p><img src="https://img-blog.csdnimg.cn/2019121115445315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsupervised Person Re-identification: Clustering and Fine-tuning 论文笔记</title>
    <url>/2020/10/12/Unsupervised-Person-Re-identification-Clustering-and-Fine-tuning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p> Hehe Fan, Liang Zheng</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>TOMM 2017</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li><p>无监督ReID，数据集没有label所以用聚类的方式产生伪标签，挑选可信样本组成新数据集，迭代训练。</p>
<a id="more"></a>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li><p>这应该是第一篇用聚类的方法来解决无监督ReID的paper</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012054004.png"></p>
</li>
<li><p>用源域上带标签的图片初始化CNN模型，</p>
</li>
<li><p>用这个模型提取目标域上图片特征，用特征相似性，聚类，保留可信样本（样本到聚类中心的余弦距离，小于某个阈值为可信样本），组成新数据集</p>
</li>
<li><p>用这个新数据集fine-tune之前的CNN模型</p>
</li>
<li><p>迭代上面步骤，直到模型收敛</p>
</li>
</ul>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012054355.png"><br>就是上面提到的内容……</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012054504.png"><br>第一篇paper，性能低正常，分析不足之处：</p>
<ul>
<li>paper里面用的聚类方法为L-means，所以需要知道K，但我们是无监督，没有label，自然无法得知K，所以这篇paper实际上是弱监督。对于这个问题可以用不指定聚类类别的方式来替代，比如HDBSCAN等等</li>
<li>需要用带标签的ReID数据集初始化模型</li>
<li>没有充分利用困难样本信息<br>最后一点是制约这篇paper性能的最主要原因，为什么这么说呢？看实验结果：<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog/clipboard_20201012055027.png"><br>图中$\lambda$为挑选可信样本时的余弦距离，我们发现当$\lambda=0.85$时性能最好，但是此时我们只用了百分之五十不到的图片（看第二张图）所以压根儿没有挖掘到困难样本信息，只是一直在用简单样本训练，性能当然不好~</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vehicle Re-identification in Aerial Imager Dataset and Approach 论文笔记</title>
    <url>/2020/08/27/Vehicle-Re-identification-in-Aerial-Imagery-Dataset-and-Approach-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Peng Wang</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>ICCV 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>现有数据集规模太小。<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li>提出一个大的车辆重识别数据集，并且手动标注属性。</li>
<li>提出一个新的车辆重识别算法，该算法能够充分利用属性。</li>
</ul>
<a id="more"></a>

<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>VeRi数据集统计信息<br><img src="https://img-blog.csdnimg.cn/20200310104420651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://img-blog.csdnimg.cn/20200310104435982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">双路网络，上面的branch为全局支路，下面的branch为属性支路</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>Vehicle Re-identification with Viewpoint-aware Metric Learning 论文笔记</title>
    <url>/2020/08/27/Vehicle-Re-identification-with-Viewpoint-aware-Metric-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Ruihang Chu, Yifan Sun</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>ICCV 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>对输入的图片用网络判断视角，对于不同视角的车辆，用不同的网络提取特征，计算样本间距离。<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2></li>
<li>提出一种新颖的viewpoint-aware metric learning approach</li>
<li>针对相同视角样本对和不同视角样本对提出空间内约束和跨空间约束</li>
</ul>
<a id="more"></a>

<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://img-blog.csdnimg.cn/20200309152511434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><ul>
<li>对view predictor单独训练，在正式训练和测试的时候，固定view predictor的参数。</li>
<li>上面的S-view branch计算相同视角图片的距离，具体为相同视角正样本对的距离$D_s(P_s^+)$和相同视角负样本对的距离$D_s(P_s^-)$，用Triplet Loss Function做约束，要求在相同视角下负样本相对于正样本到anchor的距离大于阈值$\alpha$，损失函数为$L_s=max{D_s(P_s^+)-D_s(P_s^-)+\alpha,0}$</li>
<li>下面的D-view branch计算不同视角图片的距离，具体为不同视角正样本对的距离$D_d(P_d^+)$和相同视角负样本对的距离$D_d(P_d^-)$，用Triplet Loss Function做约束，要求在不同视角下负样本相对于正样本到anchor的距离大于阈值$\alpha$，损失函数为$L_d=max{D_d(P_d^+)-D_d(P_d^-)+\alpha,0}$</li>
<li>在integrated distance matrix中，用跨域的Triplet Loss Function做约束，要求在相同视角下的负样本相对于不同视角下的正样本到anchor的距离大于阈值$\alpha$，损失函数为$L_{cross}=max{D_d(P_d^+)-D_s(P_s^-)+\alpha,0}$</li>
<li>最终的损失函数为$L=L_s+L_d+L_{cross}$<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3>测试时先将query和gallery输入到view predictor中预测视角，如果是相同视角的话，就用S-view branch计算距离，如果是不同视角的话，就用D-view branch计算距离。</li>
</ul>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://img-blog.csdnimg.cn/20200309161200552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="VehicleID"><img src="https://img-blog.csdnimg.cn/20200309161242638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="Veri-776"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>View Confusion Feature Learning for Person Re-identification论文笔记</title>
    <url>/2020/08/27/View-Confusion-Feature-Learning-for-Person-Re-identification%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>Fangyi Liu</p>
<h2 id="Conference"><a href="#Conference" class="headerlink" title="Conference"></a>Conference</h2><p>ICCV 2019</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>ReID的性能受图片拍摄视角影响，所以希望提取view-invariant特征。</p>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul>
<li>使用view confusion learning mechanism，提取视角不变性特征。</li>
<li>用SIFT特征来指导模型训练。</li>
</ul>
<a id="more"></a>

<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://img-blog.csdnimg.cn/20200311093601986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Pre-trained-CNN-Network"><a href="#Pre-trained-CNN-Network" class="headerlink" title="Pre-trained CNN Network"></a>Pre-trained CNN Network</h3><p>Pre-trained CNN Network用RAP数据集预训练，在正式训练网络时固定参数，ReID数据集的图片经过Pre-trained CNN Network后分成四类：{‘front’，‘right’，‘left’，‘back’}</p>
<h3 id="Classifier-Based-Confusion"><a href="#Classifier-Based-Confusion" class="headerlink" title="Classifier Based Confusion"></a>Classifier Based Confusion</h3><p>我们的目的是希望经过CNN提取得到的feature与视角无关，所以将feature输入到fc层经过softmax之后应该要分到common类中。Feature Extractor试图学习更好的特征，这些特征对视角具有鲁棒性，而分类器试图识别提取的特征属于哪个视图，有一种对抗学习的感觉…</p>
<h3 id="Feature-Based-Confusion"><a href="#Feature-Based-Confusion" class="headerlink" title="Feature Based Confusion"></a>Feature Based Confusion</h3><p>不同视角提取得到的特征应该接近，本文用了center loss：<br><img src="https://img-blog.csdnimg.cn/2020031110044720.png" alt="在这里插入图片描述"><br>其中$C_{y_i}$为为第i个ID的特征中心。</p>
<h3 id="Sift-Based-Confusion"><a href="#Sift-Based-Confusion" class="headerlink" title="Sift Based Confusion"></a>Sift Based Confusion</h3><p>sift特征对视角变换具有鲁棒性，所以可以用sift特征来指导训练。<br><img src="https://img-blog.csdnimg.cn/20200311100710707.png" alt="在这里插入图片描述"><br>$g(x_i)$为sift特征经过BOW后的特征向量，$f(x_i)$为CNN提取的特征向量，两者在特征空间中要接近。</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://img-blog.csdnimg.cn/20200311101121333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200311101131822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3diM2piZTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ReID</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>__add__与__iadd__</title>
    <url>/2020/10/02/add-%E4%B8%8E-iadd/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>__add__(self, other)</li>
<li>__iadd__(self, other)</li>
</ul>
<a id="more"></a>

<h2 id="add"><a href="#add" class="headerlink" title="__add__"></a>__add__</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>该方法计算self+other的值，重载+运算符</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlgNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.a * <span class="number">10</span> + other</span><br><span class="line"></span><br><span class="line">algNum = AlgNum(<span class="number">5</span>)</span><br><span class="line">print(algNum + <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">53</span></span><br></pre></td></tr></table></figure>
<h2 id="iadd-self-other"><a href="#iadd-self-other" class="headerlink" title="__iadd__(self, other)"></a>__iadd__(self, other)</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>重载 += 运算符</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlgNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.a * <span class="number">10</span> + other</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.a * <span class="number">10</span> + other</span><br><span class="line"></span><br><span class="line">algNum = AlgNum(<span class="number">5</span>)</span><br><span class="line">algNum += <span class="number">9</span></span><br><span class="line">print(algNum)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">59</span></span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>__sub__(self, other) 重载a-b</li>
<li>__isub__(self, other) 重载a-=b</li>
<li>__mul_(self, other) 重载a*b</li>
<li>__imul_(self, other) 重载a*=b</li>
<li>__mod_(self, other) 重载a%b</li>
<li>__imod_(self, other) 重载a%=b</li>
<li>__neg_(self) 重载-a</li>
<li>__pos(self) 重载+b</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>assert断言</title>
    <url>/2020/10/02/assert%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。<br>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> expression</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">if</span> <span class="string">not expression:</span></span><br><span class="line">    <span class="attr">raise</span> <span class="string">AssertionError</span></span><br></pre></td></tr></table></figure>
<p>assert 后面也可以紧跟参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> expression [, arguments]</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">assert</span> <span class="keyword">True</span>     # 条件为 <span class="keyword">true</span> 正常执行&gt;&gt;&gt; <span class="keyword">assert</span> <span class="keyword">False</span>    # 条件为 <span class="keyword">false</span> 触发异常</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, <span class="type">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AssertionError&gt;&gt;&gt; <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">1</span>    # 条件为 <span class="keyword">true</span> 正常执行&gt;&gt;&gt; <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">2</span>    # 条件为 <span class="keyword">false</span> 触发异常</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, <span class="type">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AssertionError&gt;&gt;&gt; <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">2</span>, <span class="string">&#x27;1 不等于 2&#x27;</span></span><br><span class="line">Traceback (most recent <span class="keyword">call</span> last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, <span class="type">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;AssertionError: <span class="number">1</span> 不等于 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://www.runoob.com/python3/python3-assert.html">https://www.runoob.com/python3/python3-assert.html</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>__call__</title>
    <url>/2020/10/02/call/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>原型</li>
<li>用法</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object.__call__(self[, args...])</span><br><span class="line"><span class="comment"># Called when the instance is “called” as a function; if this method is defined, x(arg1, arg2, ...) is a shorthand for x.__call__(arg1, arg2, ...).</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>主要实现的是将类的对象当作函数直接调用</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_print</span>(<span class="params">self,</span>):</span></span><br><span class="line">        print(<span class="string">&quot;a = &quot;</span>, self.a, <span class="string">&quot;b = &quot;</span>, self.b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.a = args[<span class="number">0</span>]</span><br><span class="line">        self.b = args[<span class="number">1</span>]</span><br><span class="line">        print(<span class="string">&quot;call: a = &quot;</span>, self.a, <span class="string">&quot;b = &quot;</span>, self.b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    demo = Demo(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    demo.my_print()</span><br><span class="line"></span><br><span class="line">    demo(<span class="number">50</span>, <span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">a</span> <span class="string">=</span>  <span class="number">10</span> <span class="string">b</span> <span class="string">=</span>  <span class="number">20</span></span><br><span class="line"><span class="attr">call:</span> <span class="string">a</span> <span class="string">=</span>  <span class="number">50</span> <span class="string">b</span> <span class="string">=</span>  <span class="number">60</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>copy()与deepcopy()</title>
    <url>/2020/10/19/copy-%E4%B8%8Edeepcopy/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>都是复制，但对复杂结构(比如list里面嵌套list)不同</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">b = a.copy()</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>)</span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>)</span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">33</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">c=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">--------------------</span><br><span class="line">a=</span><br><span class="line">[<span class="number">11</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">c=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">--------------------</span><br><span class="line">a=</span><br><span class="line">[<span class="number">11</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">33</span>]]</span><br><span class="line">b=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">33</span>]]</span><br><span class="line">c=</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>defaultdict用法</title>
    <url>/2020/09/30/defaultdict%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>当我使用普通的字典时，用法一般是dict={},添加元素的只需要dict[element] =value即，调用的时候也是如此，dict[element] = xxx,但前提是element字典里，如果不在字典里就会报错(可以用get方法设置缺省值)</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>defaultdict接受一个工厂函数作为参数，如下来构造</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">dict</span> =defaultdict( factory_function)</span><br></pre></td></tr></table></figure>

<p>这个factory_function可以是list、set、str等等，作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0，如下举例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections import defaultdict</span><br><span class="line"></span><br><span class="line">dict1 = defaultdict(int)</span><br><span class="line">dict2 = defaultdict(set)</span><br><span class="line">dict3 = defaultdict(str)</span><br><span class="line">dict4 = defaultdict(list)</span><br><span class="line">dict1[2] =<span class="string">&#x27;two&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span>(dict1[1])<span class="builtin-name">print</span>(dict2[1])<span class="builtin-name">print</span>(dict3[1])<span class="builtin-name">print</span>(dict4[1])</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>__delattr__和__del__</title>
    <url>/2020/10/02/delattr-%E5%92%8C-del/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>__delattr__(self, name)</li>
<li>__del__(self)</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>__delattr__(self, name)为删除类的name属性，而__del__(self)是删除类本身</p>
<a id="more"></a>

<h2 id="delattr-self-name"><a href="#delattr-self-name" class="headerlink" title="__delattr__(self, name)"></a>__delattr__(self, name)</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;running __delattr___...&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;del attribute &#123;&#125;&#x27;</span>.format(item))</span><br><span class="line">        object.__delattr__(self, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> stu1.sex</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">running</span></span> __delattr___...</span><br><span class="line">del attribute sex</span><br></pre></td></tr></table></figure>

<h2 id="del-self"><a href="#del-self" class="headerlink" title="__del__(self)"></a>__del__(self)</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;running __delattr___...&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;del attribute &#123;&#125;&#x27;</span>.format(item))</span><br><span class="line">        object.__delattr__(self, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;running __del__...&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;can not delete instance...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> stu1</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">running</span></span> __del__...</span><br><span class="line"><span class="function"><span class="title">can</span></span> <span class="keyword">not</span> delete instance...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>dict类的get方法</title>
    <url>/2020/09/30/dict%E7%B1%BB%E7%9A%84get%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>get()方法语法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">dict.<span class="builtin-name">get</span>(key, <span class="attribute">default</span>=None)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>key – 字典中要查找的键。</li>
<li>default – 如果指定键的值不存在时，返回该默认值。</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回指定键的值，如果值不在字典中返回默认值None。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">aa = &#123;<span class="string">&#x27;lab&#x27;</span>:<span class="string">&#x27;mcc&#x27;</span>, <span class="string">&#x27;school&#x27;</span>:<span class="string">&#x27;ustc&#x27;</span>&#125;</span><br><span class="line"><span class="builtin-name">print</span>(aa.<span class="builtin-name">get</span>(<span class="string">&#x27;school&#x27;</span>, <span class="string">&#x27;not find&#x27;</span>))</span><br><span class="line"><span class="builtin-name">print</span>(aa.<span class="builtin-name">get</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;not find&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">ustc</span><br><span class="line"><span class="keyword">not</span> <span class="built_in">find</span></span><br></pre></td></tr></table></figure>

<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ul>
<li>defaultdict也可以默认设置缺省值</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用指南</title>
    <url>/2020/10/02/docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>docker启动</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -itd --gpus &#x27;<span class="string">&quot;device=0,1,2,3&quot;</span>&#x27; --shm-size <span class="number">16</span> --name shensj_test -p <span class="number">3333</span>:<span class="number">22</span> -p <span class="number">3334</span>:<span class="number">6006</span> -p <span class="number">3335</span>:<span class="number">8888</span>  -v /home/shensj:/home/shensj -v /data/shensj:/data/shensj yolomax/pytorch:<span class="number">1</span>.<span class="number">6</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>docker进入</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> exec -it bc<span class="number">3</span>b<span class="number">72</span>e<span class="number">199</span>e<span class="number">2</span> /bin/bash</span><br></pre></td></tr></table></figure>
<p>docker退出</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>
<p>docker停止</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>
<p>删除container</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm -f <span class="number">1</span>e<span class="number">560</span>fca<span class="number">3906</span></span><br></pre></td></tr></table></figure>
<p>删除image</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker rmi REPOSITORY</span></span><br></pre></td></tr></table></figure>
<p>查看所有image</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure>
<p>查看所有container</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps -a</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>__getattr__</title>
    <url>/2020/10/02/getattr/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>该方法会在读取或者修改未定义的成员属性的时候调用</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; is not defined&#x27;</span>.format(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(stu1.lab)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lab</span> is not defined</span><br><span class="line"><span class="keyword">lab</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>__getitem__</title>
    <url>/2020/10/02/getitem/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>下标索引时调用</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseNum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        self.rangeList = list(range(num))</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.rangeList[self.num - item - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">reverseNum = ReverseNum(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(reverseNum[i])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>np.argwhere用法</title>
    <url>/2020/10/19/np-argwhere%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>和np.where差不多都是用来找出满足指定statement的数的index，所谓的statement就是np.where(statement)中的条件表达式，如：x==2</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>a = np.where(x==2)的结果是tuple类型的，比如（array([0], dtype=int64), array([0], dtype=int64))，而np.argwhere。a = np.argwhere(x==2) 的输出是numpy数组，比如：array([0,0], dtype=int64)</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">index1 = np.where(a&gt;<span class="number">3</span>)</span><br><span class="line">a1 = a[index1]</span><br><span class="line"></span><br><span class="line">index2 = np.argwhere(a&gt;<span class="number">3</span>)</span><br><span class="line">a2 = a[tuple(index2)]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;a = &#x27;</span>, a)</span><br><span class="line">print(<span class="string">&#x27;a1 = &#x27;</span>, a1)</span><br><span class="line">print(<span class="string">&#x27;a2 = &#x27;</span>, a2)</span><br><span class="line">print(<span class="string">&#x27;index1 = &#x27;</span>, index1)</span><br><span class="line">print(<span class="string">&#x27;index2 = &#x27;</span>, index2)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a =  [[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a1 =  [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">a2 =  [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">index1 =  (<span class="built_in">array</span>([<span class="number">1</span>, <span class="number">1</span>]), <span class="built_in">array</span>([<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">index2 =  [[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>np.linspace()和np.arange()</title>
    <url>/2020/10/05/np-linspace-%E5%92%8Cnp-arange/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>两者都是通过规定起始start和结束end来产生numpy数组，不同的是np.linspace()通过指定产生的数据num数目来产生numpy数组，而np.arange()是指定步长step</p>
<a id="more"></a>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="np-linspace"><a href="#np-linspace" class="headerlink" title="np.linspace()"></a>np.linspace()</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">numpy.linspace(start, stop, <span class="attribute">num</span>=50, <span class="attribute">endpoint</span>=<span class="literal">True</span>, <span class="attribute">retstep</span>=<span class="literal">False</span>, <span class="attribute">dtype</span>=None, <span class="attribute">axis</span>=0)</span><br></pre></td></tr></table></figure>

<ul>
<li>start为起始值</li>
<li>stop为结束值</li>
<li>num为产生数据数目</li>
<li>endpoint为是否包含结束值stop</li>
<li>dtype为产生的数据类型</li>
</ul>
<h3 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange()"></a>np.arange()</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">numpy.arange([start, ]stop, [<span class="keyword">step</span>, ]<span class="attribute">dtype</span>=None, *, <span class="attribute">like</span>=None)</span><br></pre></td></tr></table></figure>

<ul>
<li>start为起始值</li>
<li>stop为结束值</li>
<li>step为步长</li>
<li>dtype为产生的数据类型</li>
<li>注意默认不包含结束值</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>np.reshape</title>
    <url>/2020/10/05/np-reshape/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>改变numpy数组形状</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line">print(aa)</span><br><span class="line">print(aa.reshape(<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>np.zeros()和np.zeros_like()</title>
    <url>/2020/10/05/np-zeros-%E5%92%8Cnp-zeros-like/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>产生一个数值为0的numpy数组，不同的是np.zeros()通过显示指定shape的方式，而np.zeros_like()通过传入一个已经有的numpy数组，来创建和这个数组一样形状的新的全0数组。</p>
<a id="more"></a>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros()"></a>np.zeros()</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, <span class="attribute">dtype</span>=float, <span class="attribute">order</span>=<span class="string">&#x27;C&#x27;</span>, *, <span class="attribute">like</span>=None)</span><br></pre></td></tr></table></figure>

<ul>
<li>shape为数组形状，可以是int或者tuple</li>
<li>dtype为类型，默认是np.float64</li>
</ul>
<h3 id="np-zeros-like"><a href="#np-zeros-like" class="headerlink" title="np.zeros_like()"></a>np.zeros_like()</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">numpy.zeros_like(a, <span class="attribute">dtype</span>=None, <span class="attribute">order</span>=<span class="string">&#x27;K&#x27;</span>, <span class="attribute">subok</span>=<span class="literal">True</span>, <span class="attribute">shape</span>=None)</span><br></pre></td></tr></table></figure>

<ul>
<li>a为一个numpy数组</li>
<li><ul>
<li>dtype为类型，默认和数组a类型相同</li>
</ul>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>相类似的还有：</p>
<ul>
<li>np.ones()</li>
<li>np.empty()</li>
<li>np.ones_like()</li>
<li>np.empty_like()</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>np.where的用法</title>
    <url>/2020/10/09/np-where%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>第一种用法np.where(condition, x, y)</li>
<li>第二种用法np.where(condition)<a id="more"></a>
<h2 id="np-where-condition-x-y"><a href="#np-where-condition-x-y" class="headerlink" title="np.where(condition, x, y)"></a>np.where(condition, x, y)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3>满足条件(condition)，输出x，不满足输出y。<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(aa,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">array([<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>])  <span class="comment"># 0为False，所以第一个输出-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(aa &gt; <span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">array([<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where([[<span class="literal">True</span>,<span class="literal">False</span>], [<span class="literal">True</span>,<span class="literal">True</span>]],    <span class="comment"># 官网上的例子</span></span><br><span class="line">             [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]],</span><br><span class="line">             [[<span class="number">9</span>,<span class="number">8</span>], [<span class="number">7</span>,<span class="number">6</span>]])</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="np-where-condition"><a href="#np-where-condition" class="headerlink" title="np.where(condition)"></a>np.where(condition)</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>只有条件 (condition)，没有x和y，则输出满足条件 (即非0) 元素的坐标 (等价于numpy.nonzero)。这里的坐标以tuple的形式给出，通常原数组有多少维，输出的tuple中就包含几个数组，分别对应符合条件元素的各维坐标。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(a &gt; <span class="number">5</span>)             <span class="comment"># 返回索引</span></span><br><span class="line">(array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]),)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[np.where(a &gt; <span class="number">5</span>)]              <span class="comment"># 等价于 a[a&gt;5]，因为花式索引有两种，一种是下标，另一种是true false数组</span></span><br><span class="line">array([ <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">1</span>]), array([<span class="number">1</span>, <span class="number">0</span>]))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy广播</title>
    <url>/2020/10/05/numpy%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
<a id="more"></a>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h3><p>两个数组的维数不相等，但是它们的<strong>后缘维度</strong>（trailing dimension，即从末尾开始算起的维度）的轴长相符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">bb = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;aa = \n&#x27;</span>, aa)</span><br><span class="line">print(<span class="string">&#x27;bb = \n&#x27;</span>, bb)</span><br><span class="line">print(<span class="string">&#x27;aa + bb = \n&#x27;</span>, aa+bb)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">aa = </span><br><span class="line"> [[[ <span class="number">8</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">14</span>]</span><br><span class="line">  [<span class="number">14</span> <span class="number">11</span>  <span class="number">4</span> <span class="number">18</span>]</span><br><span class="line">  [<span class="number">12</span> <span class="number">19</span> <span class="number">12</span>  <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">7</span>  <span class="number">9</span>  <span class="number">4</span>  <span class="number">3</span>]</span><br><span class="line">  [<span class="number">14</span> <span class="number">19</span>  <span class="number">1</span> <span class="number">14</span>]</span><br><span class="line">  [<span class="number">12</span>  <span class="number">8</span> <span class="number">10</span>  <span class="number">3</span>]]]</span><br><span class="line">bb = </span><br><span class="line"> [[<span class="number">11</span>  <span class="number">6</span> <span class="number">14</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">15</span> <span class="number">12</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">16</span>  <span class="number">1</span> <span class="number">17</span>]]</span><br><span class="line">aa + bb = </span><br><span class="line"> [[[<span class="number">19</span> <span class="number">12</span> <span class="number">22</span> <span class="number">21</span>]</span><br><span class="line">  [<span class="number">24</span> <span class="number">26</span> <span class="number">16</span> <span class="number">21</span>]</span><br><span class="line">  [<span class="number">16</span> <span class="number">35</span> <span class="number">13</span> <span class="number">23</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">18</span> <span class="number">15</span> <span class="number">18</span> <span class="number">10</span>]</span><br><span class="line">  [<span class="number">24</span> <span class="number">34</span> <span class="number">13</span> <span class="number">17</span>]</span><br><span class="line">  [<span class="number">16</span> <span class="number">24</span> <span class="number">11</span> <span class="number">20</span>]]]</span><br></pre></td></tr></table></figure>
<p>反例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">bb = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(<span class="string">&#x27;aa = \n&#x27;</span>, aa)</span><br><span class="line">print(<span class="string">&#x27;bb = \n&#x27;</span>, bb)</span><br><span class="line">print(<span class="string">&#x27;aa + bb = \n&#x27;</span>, aa+bb)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">aa = </span><br><span class="line"> [[[ <span class="number">6</span>  <span class="number">9</span>  <span class="number">5</span>  <span class="number">3</span>]</span><br><span class="line">  [<span class="number">14</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">14</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">9</span>  <span class="number">7</span>  <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">19</span>  <span class="number">7</span> <span class="number">15</span> <span class="number">12</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">8</span>  <span class="number">1</span>  <span class="number">8</span>]</span><br><span class="line">  [<span class="number">16</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span>]]]</span><br><span class="line">bb = </span><br><span class="line"> [[ <span class="number">5</span> <span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">9</span>  <span class="number">2</span> <span class="number">18</span>]]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">&#x27;aa + bb = \n&#x27;</span>, aa+bb)</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together with shapes (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) (<span class="number">2</span>,<span class="number">3</span>) </span><br></pre></td></tr></table></figure>
<p>（2，3）与（2，3，4）后缘维度不相同</p>
<h3 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h3><p>有一方的长度为1<br>比如两个数组的维度分别是(2,1,4,1)和(2,3,4,5)，则可以广播</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy中setdiff1d的用法</title>
    <url>/2020/10/19/numpy%E4%B8%ADsetdiff1d%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setdiff1d(ar1, ar2, assume_unique=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：找到2个数组中集合元素的差异。</li>
<li>返回：在ar1中但不在ar2中的<strong>已排序</strong>的<strong>唯一值</strong>。</li>
<li>参数：<ul>
<li>ar1：array_like 输入数组。</li>
<li>ar2：array_like 输入比较数组。</li>
<li>assume_unique：bool。如果为True，则假定输入数组是唯一的，即可以加快计算速度。 默认值为False。<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>])</span><br><span class="line">c = np.setdiff1d(a, b)</span><br><span class="line">print(c)<span class="comment">#[1 2 8]</span></span><br></pre></td></tr></table></figure>
可以从最后看出返回的值<strong>从小到大排序</strong>，并且<strong>唯一</strong>。（8在a的第1位，2在a中重复了2次）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy数组增加一个新的轴</title>
    <url>/2020/10/05/numpy%E6%95%B0%E7%BB%84%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%BD%B4/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>np.newaxis可以给一个数组增加一个新的轴。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">aa = aa[:, np.newaxis, ...]</span><br><span class="line">print(aa.shape)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy数组的视图与拷贝</title>
    <url>/2020/10/05/numpy%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>当计算和操作数组时，有时会将数据复制到新数组中，有时则不会。这通常是我们混淆的根源。有三种情况：</p>
<ul>
<li>完全不复制</li>
<li>视图或浅拷贝</li>
<li>深拷贝<a id="more"></a>
<h2 id="完全不复制"><a href="#完全不复制" class="headerlink" title="完全不复制"></a>完全不复制</h2>简单的分配不会复制数组对象<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line">bb = aa</span><br><span class="line">print(id(aa))</span><br><span class="line">print(id(bb))</span><br></pre></td></tr></table></figure>
输出：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2176928950088</span></span><br><span class="line"><span class="number">2176928950088</span></span><br></pre></td></tr></table></figure>
numpy数组是可变对象，所以函数传递时，是引用传递，在函数内部修改会影响数组本身<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">aa</span>):</span></span><br><span class="line">    aa[<span class="number">0</span>] = <span class="number">111</span></span><br><span class="line"></span><br><span class="line">func(aa)</span><br><span class="line">print(aa)</span><br></pre></td></tr></table></figure>
输出：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">111</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h2 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h2>不同的数组对象可以共享相同的数据。该view方法创建一个查看相同数据的新数组对象。同时切片数组会返回一个视图。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line">bb = aa[:<span class="number">2</span>]</span><br><span class="line">bb[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">print(aa)</span><br></pre></td></tr></table></figure>
输出：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">11</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>该<strong>copy</strong>方法生成数组及其数据的完整副本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line">bb = aa.copy()</span><br><span class="line">bb[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">print(aa)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy索引技巧</title>
    <url>/2020/10/05/numpy%E7%B4%A2%E5%BC%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>NumPy提供比常规Python序列更多的索引功能。除了通过整数和切片进行索引之外，正如我们之前看到的，数组可以由整数数组和布尔数组索引。</p>
<a id="more"></a>
<h2 id="使用索引数组进行索引"><a href="#使用索引数组进行索引" class="headerlink" title="使用索引数组进行索引"></a>使用索引数组进行索引</h2><p>本质是根据下标的集合，即索引数组来提取子集，与切片的区别在于，花式索引可以提取非连续的元素，注意花式索引总是生成一个新的数组，而切片是生产视图，用法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)**<span class="number">2</span>                       <span class="comment"># the first 12 square numbers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = np.array( [ <span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span> ] )              <span class="comment"># an array of indices</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[i]                                       <span class="comment"># the elements of a at the positions i</span></span><br><span class="line">array([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">9</span>, <span class="number">64</span>, <span class="number">25</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j = np.array( [ [ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span> ] ] )      <span class="comment"># a bidimensional array of indices</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[j]                                       <span class="comment"># 生成的数组形状和j一样</span></span><br><span class="line">array([[ <span class="number">9</span>, <span class="number">16</span>],</span><br><span class="line">       [<span class="number">81</span>, <span class="number">49</span>]])</span><br></pre></td></tr></table></figure>
<p>如果被索引的数组a是多维的，那么索引数组将引用数组a的<strong>第一维</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>palette = np.array( [ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],                <span class="comment"># black</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],              <span class="comment"># red</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],              <span class="comment"># green</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],              <span class="comment"># blue</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>] ] )       <span class="comment"># white</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = np.array( [ [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> ],           <span class="comment"># each value corresponds to a color in the palette</span></span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span> ]  ] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>palette[image]                            <span class="comment"># the (2,4,3) color image</span></span><br><span class="line">array([[[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [<span class="number">255</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>, <span class="number">255</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]],</span><br><span class="line">       [[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">255</span>],</span><br><span class="line">        [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]]])</span><br></pre></td></tr></table></figure>
<p>也可以给出多于1维的索引。针对每个维的索引数组必须形状相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = np.array( [ [<span class="number">0</span>,<span class="number">1</span>],                      <span class="comment"># 第一个轴的索引</span></span><br><span class="line"><span class="meta">... </span>                [<span class="number">1</span>,<span class="number">2</span>] ] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j = np.array( [ [<span class="number">2</span>,<span class="number">1</span>],                        <span class="comment"># 第二个轴的索引</span></span><br><span class="line"><span class="meta">... </span>                [<span class="number">3</span>,<span class="number">3</span>] ] )</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[i,j]                                     <span class="comment"># i 和 j形状必须相同</span></span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="使用布尔数组进行索引"><a href="#使用布尔数组进行索引" class="headerlink" title="使用布尔数组进行索引"></a>使用布尔数组进行索引</h2><p>当我们使用（整数）索引数组索引数组时，我们提供了要选择的索引列表。使用布尔索引，方法是不同的; 我们明确地选择我们想要的数组中的哪些项目以及我们不需要的项目。<br>人们可以想到的最自然的布尔索引方法是使用与原始数组具有 相同形状的 布尔数组：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;&gt;&gt;</span> <span class="string">a</span> <span class="string">=</span> <span class="string">np.arange(12).reshape(3,4)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span> <span class="string">b</span> <span class="string">=</span> <span class="string">a</span> <span class="string">&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span> <span class="string">b</span>                                          <span class="comment"># b is a boolean with a&#x27;s shape</span></span><br><span class="line"><span class="string">array([[False,</span> <span class="literal">False</span><span class="string">,</span> <span class="literal">False</span><span class="string">,</span> <span class="literal">False</span><span class="string">],</span></span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]<span class="string">,</span></span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]<span class="string">],</span> <span class="string">dtype=bool)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span> <span class="string">a[b]</span>                                       <span class="comment"># 选中的元素组成一维数组</span></span><br><span class="line"><span class="string">array([</span> <span class="number">5</span><span class="string">,</span>  <span class="number">6</span><span class="string">,</span>  <span class="number">7</span><span class="string">,</span>  <span class="number">8</span><span class="string">,</span>  <span class="number">9</span><span class="string">,</span> <span class="number">10</span><span class="string">,</span> <span class="number">11</span><span class="string">])</span></span><br></pre></td></tr></table></figure>
<p>这个性质很适合用来给元素重新赋值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a[b] = <span class="number">0</span>                                   # All elements of <span class="string">&#x27;a&#x27;</span> higher than <span class="number">4</span> become <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line"><span class="built_in">array</span>([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.numpy.org.cn/user/quickstart.html">https://www.numpy.org.cn/user/quickstart.html</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm中配置远程docker解释器</title>
    <url>/2020/10/02/pycharm%E4%B8%AD%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8Bdocker%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h2 id="远程服务器配置"><a href="#远程服务器配置" class="headerlink" title="远程服务器配置"></a>远程服务器配置</h2><h3 id="启动一个新容器"><a href="#启动一个新容器" class="headerlink" title="启动一个新容器"></a>启动一个新容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --gpus all --user $(id -u $&#123;USER&#125;):$(id -g $&#123;USER&#125;) --shm-size 16G --name shensj_reid -p 3333:22 -p 3334:6006 -p 3335:8888 -v /etc/passwd:/etc/passwd:ro -v /etc/group:/etc/group:ro -v /etc/shadow:/etc/shadow:ro -v /home/shensj:/home/shensj -v /data/shensj:/data/shensj yolomax/pytorch:1.6.0</span><br></pre></td></tr></table></figure>
<ul>
<li>-itd表示以交互命令的方式打开docker，并且后台运行</li>
<li>–gpus表示用使用哪几块GPU卡</li>
<li>–shm-size表示交换内存，设置太小会导致dalaloader出问题</li>
<li>–name为container名称</li>
<li>-p为端口映射</li>
<li>-v为挂在系统目录<a id="more"></a>
<h3 id="进入容器启动SSH"><a href="#进入容器启动SSH" class="headerlink" title="进入容器启动SSH"></a>进入容器启动SSH</h3><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it shensj_reid <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure>
<h4 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="keyword">get</span> install openssh-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<h4 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h4>使用vim打开并修改配置文件，找到PermitRootLogin prohibit-password这一行，修改为PermitRootLogin yes，允许通过ssh远程访问docker<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>ssh/sshd_config</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="修改DOCKER密码"><a href="#修改DOCKER密码" class="headerlink" title="修改DOCKER密码"></a>修改DOCKER密码</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd</span></span><br></pre></td></tr></table></figure>

<h4 id="重启SSH"><a href="#重启SSH" class="headerlink" title="重启SSH"></a>重启SSH</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">service ssh restart</span></span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试docker container中ssh服务端口在远程服务器上的映射</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此操作在远程服务器 </span></span><br><span class="line">$ docker<span class="built_in"> port </span>&lt;your container name&gt; 22 </span><br><span class="line"><span class="comment"># 此操作将查看docker container中端口22，在远程服务器上端口的映射 </span></span><br><span class="line"><span class="comment"># 输出结果如下所示 </span></span><br><span class="line">22/tcp -&gt; 0.0.0.0:3333</span><br><span class="line"><span class="comment"># 表明只要ssh链接远程服务器的8022端口，实际是链接docker container中的22端口。</span></span><br></pre></td></tr></table></figure>

<h2 id="Pycharm客户端配置"><a href="#Pycharm客户端配置" class="headerlink" title="Pycharm客户端配置"></a>Pycharm客户端配置</h2><h3 id="代码同步"><a href="#代码同步" class="headerlink" title="代码同步"></a>代码同步</h3><p>在导航栏中 Tools&gt;Depolyment&gt;Configuration中添加配置SFTP。<br><img src="https://s1.ax1x.com/2020/10/02/0ll3Ss.png" alt="添加SFTP"></p>
<h3 id="配置远程解释器"><a href="#配置远程解释器" class="headerlink" title="配置远程解释器"></a>配置远程解释器</h3><p><img src="https://s1.ax1x.com/2020/10/02/0ll8ln.png" alt="配置远程解释器"><br><img src="https://s1.ax1x.com/2020/10/02/0llGyq.png" alt="配置远程解释器"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>raise抛出异常</title>
    <url>/2020/10/02/raise%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>用来手动抛出异常</p>
<a id="more"></a>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> [exceptionName [(reason)]]</span><br></pre></td></tr></table></figure>
<p>其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。</p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><ul>
<li>raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。</li>
<li>raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。</li>
<li>raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#1&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raiseRuntimeError: No active exception to reraise</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#0&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionErrorZeroDivisionError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ZeroDivisionError(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#2&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionError(<span class="string">&quot;除数不能为零&quot;</span>)ZeroDivisionError: 除数不能为零</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce函数</title>
    <url>/2020/09/28/reduce%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>reduce() 函数会对参数序列中元素进行<strong>累积</strong>。<br>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function -- 函数，有两个参数</span></span><br><span class="line"><span class="comment"># iterable -- 可迭代对象</span></span><br><span class="line"><span class="comment"># initializer -- 可选，初始参数</span></span><br><span class="line"><span class="comment"># return -- 数值</span></span><br><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://s1.ax1x.com/2020/09/28/0VjixH.png" alt="例子"><br>使用前务必导入库函数functools</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>__str__和__repr__</title>
    <url>/2020/10/02/str-%E5%92%8C-repr/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>__str__</li>
<li>__repr__</li>
</ul>
<h2 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>该方法被内置函数str()和print函数调用，用来设置对象以字符串类型出现时如何显示。返回值是一个字符串对象</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;repr: &#x27;</span> + self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(stu1)</span><br><span class="line">print(stu2)</span><br><span class="line">print(stu3)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">alex</span></span><br><span class="line"><span class="attribute">jinxin</span></span><br><span class="line"><span class="attribute">Egon</span></span><br></pre></td></tr></table></figure>
<h2 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a>__repr__</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>被repr函数调用，一般输出的是可悲编译器理解的字符串，用于程序员调试使用</p>
<a id="more"></a>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">print(repr(now))</span><br><span class="line">print(now)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">datetime.datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">41</span>, <span class="number">6</span>, <span class="number">902936</span>)</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">41</span>:<span class="number">06.902936</span></span><br></pre></td></tr></table></figure>
<p>再看另一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;repr: &#x27;</span> + self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(repr(stu1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">repr:</span> alex</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>__setattr__</title>
    <url>/2020/10/02/setattr/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>在对成员属性赋值时会调用</li>
</ul>
<a id="more"></a>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;running __setattr__ meathod&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;key = &#123;&#125;, value = &#123;&#125;&#x27;</span>.format(key, value))</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;jinxin&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">78</span>)</span><br><span class="line">stu3 = Student(<span class="string">&#x27;Egon&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key =<span class="built_in"> name</span>, <span class="keyword">value</span> = alex</span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key = age, <span class="keyword">value</span> = male</span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key = sex, <span class="keyword">value</span> = <span class="number">38</span></span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key =<span class="built_in"> count</span>, <span class="keyword">value</span> = <span class="number">1</span></span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key =<span class="built_in"> name</span>, <span class="keyword">value</span> = jinxin</span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key = age, <span class="keyword">value</span> = female</span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key = sex, <span class="keyword">value</span> = <span class="number">78</span></span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key =<span class="built_in"> count</span>, <span class="keyword">value</span> = <span class="number">1</span></span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key =<span class="built_in"> name</span>, <span class="keyword">value</span> = Egon</span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key = age, <span class="keyword">value</span> = male</span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key = sex, <span class="keyword">value</span> = <span class="number">18</span></span><br><span class="line">running __setattr_<span class="number">_</span> meathod</span><br><span class="line">key =<span class="built_in"> count</span>, <span class="keyword">value</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school = <span class="string">&#x27;Luffycity&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.sex = sex</span></span><br><span class="line">        <span class="comment"># self.count += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;running __setattr__ meathod&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;key = &#123;&#125;, value = &#123;&#125;&#x27;</span>.format(key, value))</span><br><span class="line">        self.name = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s is learning&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;alex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">running __setattr__ meathod</span><br><span class="line">key = <span class="type">name</span>, <span class="keyword">value</span> = alex</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">running __setattr__ meathod</span><br><span class="line">key = <span class="type">name</span>, <span class="keyword">value</span> = alex</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> last):</span><br><span class="line">  File &quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;, <span class="type">line</span> <span class="number">20</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    stu1 = Student(<span class="string">&#x27;alex&#x27;</span>)</span><br><span class="line">  File &quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;, <span class="type">line</span> <span class="number">6</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self.name = <span class="type">name</span></span><br><span class="line">  File &quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;, <span class="type">line</span> <span class="number">14</span>, <span class="keyword">in</span> __setattr__</span><br><span class="line">    self.name = <span class="keyword">value</span></span><br><span class="line">  File &quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;, <span class="type">line</span> <span class="number">14</span>, <span class="keyword">in</span> __setattr__</span><br><span class="line">    self.name = <span class="keyword">value</span></span><br><span class="line">  File &quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;, <span class="type">line</span> <span class="number">14</span>, <span class="keyword">in</span> __setattr__</span><br><span class="line">    self.name = <span class="keyword">value</span></span><br><span class="line">  [Previous <span class="type">line</span> repeated <span class="number">991</span> more times]</span><br><span class="line">  File &quot;C:/Users/64547/PycharmProjects/py1/test.py&quot;, <span class="type">line</span> <span class="number">12</span>, <span class="keyword">in</span> __setattr__</span><br><span class="line">    print(<span class="string">&#x27;running __setattr__ meathod&#x27;</span>)</span><br><span class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">while</span> calling a Python <span class="keyword">object</span></span><br></pre></td></tr></table></figure>
<p>这是因为无线循环调用了__setattr__方法</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>super()与多重继承</title>
    <url>/2020/09/28/super-%E4%B8%8E%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>super </li>
<li>mro</li>
</ul>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name1, age1, **kwargs</span>):</span></span><br><span class="line">        self.name1 = name1</span><br><span class="line">        self.age1 = age1</span><br><span class="line">        super(Person1, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;person1 eat...&#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name2, age2, **kwargs</span>):</span></span><br><span class="line">        self.name2 = name2</span><br><span class="line">        self.age2 = age2</span><br><span class="line">        super(Person2, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;person2 eat...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person1, Person2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, id, **kwargs</span>):</span></span><br><span class="line">        super(Student, self).__init__(**kwargs)</span><br><span class="line">        self.id = id</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def _eat(self):</span></span><br><span class="line">    <span class="comment">#     print(1)</span></span><br><span class="line"></span><br><span class="line">stu = Student(<span class="number">1</span>, name1=<span class="string">&#x27;shensj&#x27;</span>, age1=<span class="number">23</span>, name2=<span class="string">&#x27;panjx&#x27;</span>, age2=<span class="number">24</span>)</span><br><span class="line">stu._eat()</span><br><span class="line">print(Student.__mro__)</span><br><span class="line">print(stu.name2)</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">person<span class="number">1</span> eat...</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Student&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person1&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person2&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br><span class="line">panjx</span><br></pre></td></tr></table></figure>

<h3 id="更好的例子"><a href="#更好的例子" class="headerlink" title="更好的例子"></a>更好的例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码基于python3.8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;下图中,两根斜线是指往这个方向数的第二个类,O是object</span></span><br><span class="line"><span class="string">O</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">G</span></span><br><span class="line"><span class="string">| \ \</span></span><br><span class="line"><span class="string">D E  F</span></span><br><span class="line"><span class="string">|/\\/</span></span><br><span class="line"><span class="string">B  C</span></span><br><span class="line"><span class="string">| /</span></span><br><span class="line"><span class="string">A </span></span><br><span class="line"><span class="string">mro=ABCDEFGO</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, g, **kargs</span>):</span>  <span class="comment"># g是本构造器自身需要的参数,用位置参数将指提取出来,而kargs则是剩余的关键字参</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ G&quot;</span>)  <span class="comment"># 数,用于传递给下一层的__init__()</span></span><br><span class="line">        self.g = g</span><br><span class="line">        super(G, self).__init__(**kargs)  <span class="comment"># 为了和python2的新式类兼容,手动把super的两个参数填上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, d, **kargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ D&quot;</span>)</span><br><span class="line">        self.d = d</span><br><span class="line">        super(D, self).__init__(**kargs)  <span class="comment"># 调用__init__时,只写**kargs,因为super返回的偏函数自动填充了self参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, e=<span class="number">100</span>, **kargs</span>):</span>  <span class="comment"># 给 本类初始化所需要的位置参数 一个默认值,使得传参时可以省掉这个参数</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ E&quot;</span>)</span><br><span class="line">        self.e = e</span><br><span class="line">        super(E, self).__init__(**kargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, f=None, **kargs</span>):</span>  <span class="comment"># 即使这个参数没有默认值,最好也给它一个默认值None,除非这个参数是必须要给出的</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ F&quot;</span>)</span><br><span class="line">        self.f = f</span><br><span class="line">        super(F, self).__init__(**kargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">D, E</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, b, **kargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ B&quot;</span>)</span><br><span class="line">        self.b = b</span><br><span class="line">        super(B, self).__init__(**kargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">D, F</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, c, **kargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ C&quot;</span>)</span><br><span class="line">        self.c = c</span><br><span class="line">        super(C, self).__init__(**kargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, **kargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter __init__ A&quot;</span>)</span><br><span class="line">        self.a = a</span><br><span class="line">        super(A, self).__init__(**kargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter play A&quot;</span>)</span><br><span class="line">        print(self.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aa = A(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>, e=<span class="number">5</span>, f=<span class="number">6</span>, g=<span class="number">7</span>)  <span class="comment"># 或者A(1,b=2,...)也可以,但是A(1,2,c=3,..)不可以</span></span><br><span class="line">aa.play()  <span class="comment"># 也就是说位置参数可以用位置参数或者关键字参数传递,但是**关键字参数不能用位置参数传递</span></span><br><span class="line"></span><br><span class="line">bb = A(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>, g=<span class="number">5</span>)</span><br><span class="line">bb.play()  <span class="comment"># out: &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;e&#x27;: 100, &#x27;f&#x27;: None, &#x27;g&#x27;: 5&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">enter <span class="variable">__init__</span> A</span><br><span class="line">enter <span class="variable">__init__</span> B</span><br><span class="line">enter <span class="variable">__init__</span> C</span><br><span class="line">enter <span class="variable">__init__</span> D</span><br><span class="line">enter <span class="variable">__init__</span> E</span><br><span class="line">enter <span class="variable">__init__</span> F</span><br><span class="line">enter <span class="variable">__init__</span> G</span><br><span class="line">enter play A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line">enter <span class="variable">__init__</span> A</span><br><span class="line">enter <span class="variable">__init__</span> B</span><br><span class="line">enter <span class="variable">__init__</span> C</span><br><span class="line">enter <span class="variable">__init__</span> D</span><br><span class="line">enter <span class="variable">__init__</span> E</span><br><span class="line">enter <span class="variable">__init__</span> F</span><br><span class="line">enter <span class="variable">__init__</span> G</span><br><span class="line">enter play A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;f&#x27;</span>: None, <span class="string">&#x27;g&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python迭代器</title>
    <url>/2020/10/03/%E2%80%9CPython%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>凡是定义了__iter__和__next__方法的对象都是可迭代对象</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end, step</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line">        self.step = step</span><br><span class="line">        self.cur = start</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.cur &lt; self.end:</span><br><span class="line">            x = self.cur</span><br><span class="line">            self.cur += self.step</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">myRange = MyRange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">myRange = iter(myRange)</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line">print(next(myRange))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in MyRange(0,10,3):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(&#x27;end.....&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;C:/Users/64547/PycharmProjects/py1/test2.py&quot;</span>, line <span class="number">26</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print(<span class="keyword">next</span>(myRange))</span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;C:/Users/64547/PycharmProjects/py1/test2.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> __next__</span><br><span class="line">    <span class="keyword">raise</span> StopIteration</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>torch.expand和torch.repeat</title>
    <url>/2020/10/19/torch-expand%E5%92%8Ctorch-repeat/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>这两个方法都用作按照某一维度扩展数组，区别是<strong>扩展（expand）</strong>张量不会分配新的内存，只是在存在的张量上创建一个新的视图（view），一个<strong>大小（size）等于1的维度</strong>扩展到更大的尺寸。而**repeat()**会拷贝张量的数据。</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="torch-expand"><a href="#torch-expand" class="headerlink" title="torch.expand"></a>torch.expand</h3><p>expand后面的参数为改变后的尺寸，用[]括号包起来，注意只能大小为1的维度操作，或者没有这个维度，先通过广播创建一个大小为1的新维度，然后再expand</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">&gt;&gt; x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt;&gt; x.expand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"> </span><br><span class="line">&gt;&gt; x = torch.randn(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt; x.expand(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>)</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  </span><br></pre></td></tr></table></figure>
<h3 id="torch-repeat"><a href="#torch-repeat" class="headerlink" title="torch.repeat"></a>torch.repeat</h3><p>沿着特定的维度重复这个张量，和expand()不同的是，这个函数拷贝张量的数据。参数为重复次数，用()括号包起来，可对任意维度做处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">&gt;&gt; x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt;&gt; x.repeat(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">&gt;&gt; x2 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt; x2.repeat(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).shape</span><br><span class="line">torch.Tensor([<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>内置filter函数</title>
    <url>/2020/09/28/%E5%86%85%E7%BD%AEfilter%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>filter() 函数用于<strong>过滤序列</strong>，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function -- 判断函数</span></span><br><span class="line"><span class="comment"># iterable -- 可迭代对象</span></span><br><span class="line"><span class="comment"># return -- 迭代器</span></span><br><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure>
<p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://s1.ax1x.com/2020/09/28/0VjMRg.png" alt="例子"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>内置map函数</title>
    <url>/2020/09/28/%E5%86%85%E7%BD%AEmap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>map() 会根据提供的函数对指定序列做<strong>映射</strong>。</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function -- 判断函数</span></span><br><span class="line"><span class="comment"># iterable -- 可迭代对象</span></span><br><span class="line"><span class="comment"># return -- 迭代器</span></span><br><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://s1.ax1x.com/2020/09/28/0VjJZq.png" alt="例子"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>函数形参传递</title>
    <url>/2020/09/28/%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="参数传递类型"><a href="#参数传递类型" class="headerlink" title="参数传递类型"></a>参数传递类型</h2><p>值传递：适用于实参类型为<strong>不可变</strong>类型（字符串、数字、元组）；<br>引用传递：适用于实参类型为<strong>可变</strong>类型（列表，字典，numpy数组）；</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>创建numpy数组的几种常用方式</title>
    <url>/2020/10/05/%E5%88%9B%E5%BB%BAnumpy%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h2><ul>
<li>np.array()</li>
<li>np.zeros()</li>
<li>np.ones()</li>
<li>np.empty()</li>
<li>np.arange()</li>
<li>np.linspace()</li>
<li>np.zeros_like()</li>
<li>np.ones_like()</li>
<li>np.empty_like()</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>创建多个Github Pages</title>
    <url>/2020/10/07/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAGithub-Pages/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人会将自己的个人主页挂载在github上，这时就需要创建用户站点，用户站点的仓库名必须是<code>&lt;user&gt;.github.io</code>，做完这一步之后，很多人会和我有一样的想法——搭建多个Github Pages页面。这些页面可以用来实现不同的功能，比如放ACG，放网站导航等等。之前一直以为每个用户只能拥有一个Github Pages（这个就是上文提到的<code>&lt;user&gt;.github.io</code>仓库），现在查阅各种资料之后，发现不是这么一回事，下面讲述我搭建第二个Github Pages时遇到的各种坑~</p>
<a id="more"></a>
<h2 id="Github-Pages分类"><a href="#Github-Pages分类" class="headerlink" title="Github Pages分类"></a>Github Pages分类</h2><p>查阅文档之后发现，Github Pages有三类，分别是用户站点，组织站点和<strong>项目站点</strong>，其中用户/组织站点只能创建一个，同时要发布用户站点，必须创建名为 <code>&lt;user&gt;.github.io</code> 的用户帐户所拥有的仓库。 要发布组织站点，必须创建名为 <code>&lt;organization&gt;.github.io</code> 的组织所拥有的仓库。 除非您使用自定义域，否则用户和组织站点位于 <code>http(s)://&lt;username&gt;.github.io</code> 或  <code>http(s)://&lt;organization&gt;.github.io</code>。而<strong>项目站点</strong>却可以创建多个，比如为这个项目创建一个名为<code>acg</code>的仓库，我们将项目站点源文件传到这个仓库，那么我们就可以用<code>http(s)://&lt;user&gt;.github.io/acg</code>来访问这个项目站点。</p>
<h2 id="搭建站点"><a href="#搭建站点" class="headerlink" title="搭建站点"></a>搭建站点</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我已经搭建了个人博客，地址为：<code>https://blog.shensanjing.site/</code>，现在我要创建一个网站导航项目站点，站点示意图如下：<br><img src="https://s1.ax1x.com/2020/10/07/0aLKMD.png" alt="个人站点"><br><img src="https://s1.ax1x.com/2020/10/07/0aLtRf.png" alt="导航页面"></p>
<h3 id="搭建导航页面"><a href="#搭建导航页面" class="headerlink" title="搭建导航页面"></a>搭建导航页面</h3><ol>
<li>创建一个新的仓库，仓库名叫做<code>nav</code></li>
<li>克隆webstack，地址为：<code>https://github.com/HCLonely/hexo-theme-webstack</code>，因为网站导航是子页面，所以要将_config.yml的URL设置为你的个人站点网址，root设置为你的仓库名，我的设置为<code>url: https://blog.shensanjing.site</code>和<code>root: /nav/</code>，不这么做，会导致没有样式。</li>
<li>同时还要将webstack的所有图片连接加上<code>/nav/</code>，否则将无法显示图片。</li>
<li>经过上面三步，已经可以用<code>https://blog.shensanjing.site/nav/</code>来访问网站</li>
<li>接下来，只要在个人主页项目上加上导航标签即可。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/183977963">https://zhuanlan.zhihu.com/p/183977963</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>在多台电脑上提交和更新Hexo博客</title>
    <url>/2020/10/22/%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="部署远程仓库"><a href="#部署远程仓库" class="headerlink" title="部署远程仓库"></a>部署远程仓库</h2><p>将本地的博客源文件同步到远程仓库，具体过程如下：</p>
<ol>
<li>删除第三方主题下的.git文件夹；</li>
<li>配置.gitignore文件：<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">.DS_Store</span></span><br><span class="line">Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line"><span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line"><span class="meta">public</span>/</span><br><span class="line"><span class="meta">.deploy</span>*/</span><br></pre></td></tr></table></figure></li>
<li>创建远程仓库，建议将源文件推送到私有仓库（感谢微软爸爸，让我们免费使用私有仓库）<br><img src="https://myblog-1256619596.cos.ap-shanghai.myqcloud.com/myblog2/20201022/clipboard_20201022031632.png"></li>
<li>将项目源文件同步到远程仓库的master分支：<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git init  <span class="regexp">//</span>初始化本地仓库</span><br><span class="line">git add -A <span class="regexp">//</span>添加本地所有文件到仓库        </span><br><span class="line">git commit -m &amp;quot;blog源文件&amp;quot; <span class="regexp">//</span>添加commit</span><br><span class="line">git remote add origin 博客的git地址  <span class="regexp">//</span>添加远程仓库</span><br><span class="line">git push origin master <span class="regexp">//</span>将本地仓库的源文件推送到远程仓库hexo分支</span><br></pre></td></tr></table></figure>
如果出现错误信息：<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> remote origin already <span class="built_in">exists</span>.</span><br></pre></td></tr></table></figure>
则需要：<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure>
再添加远程仓库即可。</li>
</ol>
<h2 id="更新远程和本地仓库"><a href="#更新远程和本地仓库" class="headerlink" title="更新远程和本地仓库"></a>更新远程和本地仓库</h2><p>对于本地电脑，如果是第一次使用，则输入：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">你的仓库地址</span></span><br><span class="line"><span class="title">cd</span> 本地目录</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>如果不是第一次操作，对于本地仓库的更新，可执行：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git pull</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>数组堆叠</title>
    <url>/2020/10/05/%E6%95%B0%E7%BB%84%E5%A0%86%E5%8F%A0/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>有时候需要把两个或多个数组按照某一个axis进行堆叠</p>
<a id="more"></a>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="np-stack"><a href="#np-stack" class="headerlink" title="np.stack()"></a>np.stack()</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>该函数的作用是沿着新轴连接数组的序列。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">numpy.stack(<span class="built_in">array</span>s, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>arrays中的每个数组必须要有相同的形状</li>
<li>axis为新加轴的位置</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line">bb = np.array([[<span class="number">11</span>,<span class="number">22</span>],[<span class="number">33</span>,<span class="number">44</span>],[<span class="number">44</span>,<span class="number">55</span>],[<span class="number">66</span>,<span class="number">77</span>]])</span><br><span class="line">cc = np.stack((aa,bb), axis=<span class="number">0</span>)</span><br><span class="line">print(aa.shape)</span><br><span class="line">print(bb.shape)</span><br><span class="line">print(cc.shape)</span><br><span class="line">print(cc)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">[[[ <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">11</span> <span class="number">22</span>]</span><br><span class="line">  [<span class="number">33</span> <span class="number">44</span>]</span><br><span class="line">  [<span class="number">44</span> <span class="number">55</span>]</span><br><span class="line">  [<span class="number">66</span> <span class="number">77</span>]]]</span><br></pre></td></tr></table></figure>

<h3 id="np-vstack"><a href="#np-vstack" class="headerlink" title="np.vstack()"></a>np.vstack()</h3><h4 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h4><p>按照第一个维度进行堆叠，如果是一维数组进行堆叠，则数组长度必须相同；除此之外，其它数组堆叠时，除数组第一个轴的长度可以不同，其它轴长度必须一样。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">np</span><span class="selector-class">.vstack</span>(<span class="selector-tag">tup</span>)</span><br></pre></td></tr></table></figure>

<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>一维数组：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a = np.<span class="built_in">array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.<span class="built_in">array</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<p>多维数组：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">aa = np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">bb = np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">cc = np.vstack((aa,bb))</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(aa.shape)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(bb.shape)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(cc.shape)</span></span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="np-hstack"><a href="#np-hstack" class="headerlink" title="np.hstack()"></a>np.hstack()</h3><h4 id="原型-2"><a href="#原型-2" class="headerlink" title="原型"></a>原型</h4><p>按照第二个轴进行堆叠；但如果是一维数组则按第一个轴进行堆叠</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">np</span><span class="selector-class">.hstack</span>(<span class="selector-tag">tup</span>)</span><br></pre></td></tr></table></figure>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>一维数组：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a = np.<span class="built_in">array</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">b = np.<span class="built_in">array</span>((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">np.hstack((a,b))</span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>多维数组：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a = np.<span class="built_in">array</span>([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])</span><br><span class="line">b = np.<span class="built_in">array</span>([[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]])</span><br><span class="line">np.hstack((a,b))</span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">array</span>([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="np.concatenate()"></a>np.concatenate()</h3><h4 id="原型-3"><a href="#原型-3" class="headerlink" title="原型"></a>原型</h4><p>按照已有的某个轴进行堆叠</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">concatenate</span>((a<span class="number">1</span>, a<span class="number">2</span>, …), axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>axis是堆叠的轴，除了这个轴以外的所有轴都要相同</li>
</ul>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">bb = np.empty((<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">cc = np.concatenate((aa,bb), axis=<span class="number">0</span>)</span><br><span class="line">print(aa.shape)</span><br><span class="line">print(bb.shape)</span><br><span class="line">print(cc.shape)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>多维数组的迭代</title>
    <url>/2020/10/05/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>通常我们需要对一个numpy数组进行迭代操作，比如for循环，但直接对数组本身进行循环，实际上是对第一个轴进行操作，如果要对数组中的每个值进行操作，可以使用<strong>flat</strong>属性</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> aa:</span><br><span class="line">    print(a)</span><br><span class="line">print(<span class="string">&#x27;------------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> aa.flat:</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>...是个啥</title>
    <url>/2020/10/05/%E6%98%AF%E4%B8%AA%E5%95%A5/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>三个点（ … ）表示产生完整索引元组所需的冒号。就是代表任意维度</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>例如，如果 x 是rank为5的数组（即，它具有5个轴），则：</p>
<ul>
<li>x[1,2,…] 相当于 x[1,2,:,:,:]</li>
<li>x[…,3] 等效于 x[:,:,:,:,3]</li>
<li>x[4,…,5,:] 等效于 x[4,:,:,5,:]</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法和对应元素相乘</title>
    <url>/2020/10/05/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%92%8C%E5%AF%B9%E5%BA%94%E5%85%83%E7%B4%A0%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>与许多矩阵语言不同，乘积运算符*在NumPy数组中按元素进行运算。矩阵乘积可以使用@运算符（在python&gt; = 3.5中）或dot函数或方法执行：</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">aa = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">bb = np.array([[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">print(aa*bb)</span><br><span class="line">print(aa@bb)</span><br><span class="line">print(aa.dot(bb))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">4</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">18</span> <span class="number">28</span>]]</span><br><span class="line">[[<span class="number">16</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">36</span> <span class="number">43</span>]]</span><br><span class="line">[[<span class="number">16</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">36</span> <span class="number">43</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>第三方库pathlib</title>
    <url>/2020/09/28/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93pathlib/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>Path类：from pathlib import Path</p>
<a id="more"></a>

<h3 id="Path类"><a href="#Path类" class="headerlink" title="Path类"></a>Path类</h3><h4 id="创建Path对象"><a href="#创建Path对象" class="headerlink" title="创建Path对象"></a>创建Path对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以这么使用,相当于os.path.join() </span></span><br><span class="line">p1 = Path(<span class="string">&#x27;D:/python&#x27;</span>) </span><br><span class="line">p2 = p1/<span class="string">&#x27;123&#x27;</span> </span><br><span class="line">print(p2)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">D:<span class="symbol">\p</span>ython<span class="symbol">\1</span>23</span><br></pre></td></tr></table></figure>

<h4 id="Path-exists"><a href="#Path-exists" class="headerlink" title="Path.exists()"></a>Path.exists()</h4><p>判断当前路径是否是文件或者文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">&#x27;.&#x27;</span>).exists()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">&#x27;1.py&#x27;</span>).exists()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">&#x27;2.py&#x27;</span>).exists()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="Path-glob-pattern-与Path-rglob-pattern"><a href="#Path-glob-pattern-与Path-rglob-pattern" class="headerlink" title="Path.glob(pattern)与Path.rglob(pattern)"></a>Path.glob(pattern)与Path.rglob(pattern)</h4><p>Path.glob(pattern):获取路径下的所有符合pattern的文件，返回一个generator</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[_ <span class="keyword">for</span> _ <span class="keyword">in</span> p.glob(<span class="string">&#x27;*&#x27;</span>)]</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line">[PosixPath(<span class="string">&#x27;/home/shensj/code/baseline/lib&#x27;</span>),</span><br><span class="line"> PosixPath(<span class="string">&#x27;/home/shensj/code/baseline/tasks&#x27;</span>),</span><br><span class="line"> PosixPath(<span class="string">&#x27;/home/shensj/code/baseline/pbs&#x27;</span>),</span><br><span class="line"> PosixPath(<span class="string">&#x27;/home/shensj/code/baseline/script&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>Path.rglob(pattern):与上面类似，只不过是返回路径中所有子文件夹的符合pattern的文件。</p>
<h4 id="Path-is-dir-与Path-is-file"><a href="#Path-is-dir-与Path-is-file" class="headerlink" title="Path.is_dir()与Path.is_file()"></a>Path.is_dir()与Path.is_file()</h4><p>Path.is_dir()判断该路径是否是文件夹<br>Path.is_file()判断该路径是否是文件</p>
<h4 id="Path-iterdir"><a href="#Path-iterdir" class="headerlink" title="Path.iterdir()"></a>Path.iterdir()</h4><p>当path为文件夹时，通过yield产生path文件夹下的所有文件、文件夹路径的迭代器</p>
<h4 id="Path-mkdir-mode-0o777-parents-Fasle"><a href="#Path-mkdir-mode-0o777-parents-Fasle" class="headerlink" title="Path.mkdir(mode=0o777,parents=Fasle)"></a>Path.mkdir(mode=0o777,parents=Fasle)</h4><p>根据路径创建文件夹<br>parents=True时，会依次创建路径中间缺少的文件夹</p>
<h4 id="Path-open-mode-’r’-buffering-1-encoding-None-errors-None-newline-None"><a href="#Path-open-mode-’r’-buffering-1-encoding-None-errors-None-newline-None" class="headerlink" title="Path.open(mode=’r’, buffering=-1, encoding=None, errors=None, newline=None)"></a>Path.open(mode=’r’, buffering=-1, encoding=None, errors=None, newline=None)</h4><p>类似于open()函数</p>
<h4 id="Path-match-pattern"><a href="#Path-match-pattern" class="headerlink" title="Path.match(pattern)"></a>Path.match(pattern)</h4><p>判断path是否满足pattern</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义异常</title>
    <url>/2020/10/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>实际开发中，有时候系统提供的异常类型不能满足开发的需求。这时候你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。</p>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.用户自定义异常类型，只要该类继承了Exception类即可，至于类的主题内容用户自定义，可参考官方异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooLongExceptin</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;this is user&#x27;s Exception for check the length of name &quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,leng</span>):</span></span><br><span class="line">        self.leng = leng</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;姓名长度是&quot;</span>+str(self.leng)+<span class="string">&quot;，超过长度了&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
